Grammar:

Rule 0     S' -> program
Rule 1     program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
Rule 2     gvars -> VAR datatype gvarids store_gtype ; gvars
Rule 3     gvars -> <empty>
Rule 4     gvarids -> ID
Rule 5     gvarids -> ID , gvarids
Rule 6     gvarids -> <empty>
Rule 7     store_gvars -> <empty>
Rule 8     store_gtype -> <empty>
Rule 9     vars -> VAR datatype varids store_type ; vars
Rule 10    vars -> <empty>
Rule 11    varids -> ID darray
Rule 12    varids -> ID darray , varids
Rule 13    varids -> <empty>
Rule 14    store_type -> <empty>
Rule 15    darray -> <empty>
Rule 16    darray -> [ INT ] twodarray
Rule 17    twodarray -> <empty>
Rule 18    twodarray -> [ INT ]
Rule 19    functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
Rule 20    functions -> <empty>
Rule 21    funcontent -> <empty>
Rule 22    funcontent -> statement funcontent
Rule 23    params -> ID : datatype , params
Rule 24    params -> ID : datatype
Rule 25    params -> <empty>
Rule 26    main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent }
Rule 27    maincontent -> <empty>
Rule 28    maincontent -> statement maincontent
Rule 29    statement -> loop unload_pv
Rule 30    statement -> input unload_pv
Rule 31    statement -> output unload_pv
Rule 32    statement -> ifelse unload_pv
Rule 33    statement -> returns unload_pv ;
Rule 34    statement -> expr ;
Rule 35    statement -> var_assign unload_pv
Rule 36    statement -> <empty>
Rule 37    statement -> statement statement
Rule 38    var_assign -> idarray store_oper = expr ;
Rule 39    var_assign -> idarray store_oper = ID store_oper ;
Rule 40    var_assign -> ID store_oper = idarray ;
Rule 41    var_assign -> idarray store_oper = idarray store_oper ;
Rule 42    var_assign -> ID store_oper = expr ;
Rule 43    returns -> RETURN expr store_rquad
Rule 44    ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
Rule 45    ifelse -> IF ( expr ) store_gotof { statement } store_endif
Rule 46    output -> OUTPUT ( expr outex ) ;
Rule 47    outex -> <empty>
Rule 48    outex -> , expr outex
Rule 49    input -> INPUT ( ID store_oper ) ;
Rule 50    loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop
Rule 51    expr -> arexp exprx
Rule 52    exprx -> <empty>
Rule 53    exprx -> exprop arexp
Rule 54    exprop -> OR
Rule 55    exprop -> EQEQ
Rule 56    exprop -> DIFF
Rule 57    exprop -> AND
Rule 58    exprop -> <
Rule 59    exprop -> LOETHAN
Rule 60    exprop -> >
Rule 61    exprop -> GOETHAN
Rule 62    arexp -> term arexpextra
Rule 63    arexp -> term
Rule 64    arexpextra -> <empty>
Rule 65    arexpextra -> - term arexpextra  [precedence=left, level=1]
Rule 66    arexpextra -> + term arexpextra  [precedence=left, level=1]
Rule 67    term -> factor termx
Rule 68    term -> factor
Rule 69    termx -> <empty>
Rule 70    termx -> / factor termx  [precedence=left, level=2]
Rule 71    termx -> * factor termx  [precedence=left, level=2]
Rule 72    factor -> element
Rule 73    factor -> ( store_op expr ) store_op
Rule 74    element -> idarray store_oper
Rule 75    element -> callfunc store_oper
Rule 76    element -> compound store_oper
Rule 77    element -> const store_const
Rule 78    compound -> compoundx
Rule 79    compoundx -> ID store_oper
Rule 80    const -> STRING
Rule 81    const -> FLOAT
Rule 82    const -> INT
Rule 83    const -> FALSE
Rule 84    const -> TRUE
Rule 85    callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
Rule 86    callfuncpar -> <empty>
Rule 87    callfuncpar -> expr store_pquad callfuncparx
Rule 88    callfuncparx -> <empty>
Rule 89    callfuncparx -> , callfuncpar
Rule 90    idarray -> ID [ add_fstack expr end_fstack ]
Rule 91    array -> <empty>
Rule 92    datatype -> VOID
Rule 93    datatype -> D_BOOL
Rule 94    datatype -> D_STRING
Rule 95    datatype -> D_FLOAT
Rule 96    datatype -> D_INT
Rule 97    check_program -> <empty>
Rule 98    store_init_quad -> <empty>
Rule 99    store_funcm -> <empty>
Rule 100   store_funcv -> <empty>
Rule 101   store_params -> <empty>
Rule 102   store_local_vars -> <empty>
Rule 103   store_mainv -> <empty>
Rule 104   store_op -> <empty>
Rule 105   store_oper -> <empty>
Rule 106   store_const -> <empty>
Rule 107   unload_pv -> <empty>
Rule 108   store_rquad -> <empty>
Rule 109   store_argquad -> <empty>
Rule 110   add_dirb -> <empty>
Rule 111   close_func -> <empty>
Rule 112   store_endif -> <empty>
Rule 113   store_pquad -> <empty>
Rule 114   ver_params -> <empty>
Rule 115   verify_func -> <empty>
Rule 116   add_fstack -> <empty>
Rule 117   end_fstack -> <empty>
Rule 118   store_gosub -> <empty>
Rule 119   store_gotof -> <empty>
Rule 120   store_jump -> <empty>
Rule 121   end_loop -> <empty>

Unused terminals:

    COMMENT

Terminals, with rules where they appear:

(                    : 19 26 44 45 46 49 50 73 85
)                    : 19 26 44 45 46 49 50 73 85
*                    : 71
+                    : 66
,                    : 5 12 23 48 89
-                    : 65
/                    : 70
:                    : 23 24
;                    : 1 2 9 33 34 38 39 40 41 42 46 49
<                    : 58
=                    : 38 39 40 41 42
>                    : 60
AND                  : 57
COMMENT              : 
DIFF                 : 56
D_BOOL               : 93
D_FLOAT              : 95
D_INT                : 96
D_STRING             : 94
ELSE                 : 44
EQEQ                 : 55
FALSE                : 83
FLOAT                : 81
FUNC                 : 19 26
GOETHAN              : 61
ID                   : 1 4 5 11 12 19 23 24 39 40 42 49 79 85 90
IF                   : 44 45
INPUT                : 49
INT                  : 16 18 82
LOETHAN              : 59
MAIN                 : 26
OR                   : 54
OUTPUT               : 46
PROG                 : 1
RETURN               : 43
STRING               : 80
TRUE                 : 84
VAR                  : 2 9
VOID                 : 92
WHILE                : 50
[                    : 16 18 90
]                    : 16 18 90
error                : 
{                    : 19 26 44 44 45 50
}                    : 19 26 44 44 45 50

Nonterminals, with rules where they appear:

add_dirb             : 
add_fstack           : 85 90
arexp                : 51 53
arexpextra           : 62 65 66
array                : 
callfunc             : 75
callfuncpar          : 85 89
callfuncparx         : 87
check_program        : 1
close_func           : 19
compound             : 76
compoundx            : 78
const                : 77
darray               : 11 12
datatype             : 2 9 19 23 24
element              : 72
end_fstack           : 85 90
end_loop             : 50
expr                 : 34 38 42 43 44 45 46 48 50 73 87 90
exprop               : 53
exprx                : 51
factor               : 67 68 70 71
funcontent           : 19 22
functions            : 1 19
gvarids              : 2 5
gvars                : 1 1 2
idarray              : 38 39 40 41 41 74
ifelse               : 32
input                : 30
loop                 : 29
main                 : 1
maincontent          : 26 28
outex                : 46 48
output               : 31
params               : 19 23
program              : 0
returns              : 33
statement            : 22 28 37 37 44 44 45 50
store_argquad        : 
store_const          : 77
store_endif          : 44 45
store_funcm          : 26
store_funcv          : 19
store_gosub          : 85
store_gotof          : 44 45 50
store_gtype          : 2
store_gvars          : 1 1
store_init_quad      : 19
store_jump           : 50
store_local_vars     : 19
store_mainv          : 26
store_op             : 73 73
store_oper           : 38 39 39 40 41 41 42 49 74 75 76 79
store_params         : 19
store_pquad          : 87
store_rquad          : 43
store_type           : 9
term                 : 62 63 65 66
termx                : 67 70 71
twodarray            : 16
unload_pv            : 29 30 31 32 33 35
var_assign           : 35
varids               : 9 12
vars                 : 9 19 26
ver_params           : 85
verify_func          : 85


state 0

    (0) S' -> . program
    (1) program -> . PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
    PROG            shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROG . ID check_program ; gvars store_gvars functions gvars store_gvars main
    ID              shift and go to state 3


state 3

    (1) program -> PROG ID . check_program ; gvars store_gvars functions gvars store_gvars main
    (97) check_program -> .
    ;               reduce using rule 97 (check_program -> .)

    check_program                  shift and go to state 4

state 4

    (1) program -> PROG ID check_program . ; gvars store_gvars functions gvars store_gvars main
    ;               shift and go to state 5


state 5

    (1) program -> PROG ID check_program ; . gvars store_gvars functions gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    VOID            reduce using rule 3 (gvars -> .)
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 6

state 6

    (1) program -> PROG ID check_program ; gvars . store_gvars functions gvars store_gvars main
    (7) store_gvars -> .
    VOID            reduce using rule 7 (store_gvars -> .)
    D_BOOL          reduce using rule 7 (store_gvars -> .)
    D_STRING        reduce using rule 7 (store_gvars -> .)
    D_FLOAT         reduce using rule 7 (store_gvars -> .)
    D_INT           reduce using rule 7 (store_gvars -> .)
    VAR             reduce using rule 7 (store_gvars -> .)
    FUNC            reduce using rule 7 (store_gvars -> .)

    store_gvars                    shift and go to state 8

state 7

    (2) gvars -> VAR . datatype gvarids store_gtype ; gvars
    (92) datatype -> . VOID
    (93) datatype -> . D_BOOL
    (94) datatype -> . D_STRING
    (95) datatype -> . D_FLOAT
    (96) datatype -> . D_INT
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 9

state 8

    (1) program -> PROG ID check_program ; gvars store_gvars . functions gvars store_gvars main
    (19) functions -> . datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (20) functions -> .
    (92) datatype -> . VOID
    (93) datatype -> . D_BOOL
    (94) datatype -> . D_STRING
    (95) datatype -> . D_FLOAT
    (96) datatype -> . D_INT
    VAR             reduce using rule 20 (functions -> .)
    FUNC            reduce using rule 20 (functions -> .)
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    functions                      shift and go to state 15
    datatype                       shift and go to state 16

state 9

    (2) gvars -> VAR datatype . gvarids store_gtype ; gvars
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    (6) gvarids -> .
    ID              shift and go to state 18
    ;               reduce using rule 6 (gvarids -> .)

    gvarids                        shift and go to state 17

state 10

    (92) datatype -> VOID .
    ID              reduce using rule 92 (datatype -> VOID .)
    ;               reduce using rule 92 (datatype -> VOID .)
    FUNC            reduce using rule 92 (datatype -> VOID .)
    ,               reduce using rule 92 (datatype -> VOID .)
    )               reduce using rule 92 (datatype -> VOID .)


state 11

    (93) datatype -> D_BOOL .
    ID              reduce using rule 93 (datatype -> D_BOOL .)
    ;               reduce using rule 93 (datatype -> D_BOOL .)
    FUNC            reduce using rule 93 (datatype -> D_BOOL .)
    ,               reduce using rule 93 (datatype -> D_BOOL .)
    )               reduce using rule 93 (datatype -> D_BOOL .)


state 12

    (94) datatype -> D_STRING .
    ID              reduce using rule 94 (datatype -> D_STRING .)
    ;               reduce using rule 94 (datatype -> D_STRING .)
    FUNC            reduce using rule 94 (datatype -> D_STRING .)
    ,               reduce using rule 94 (datatype -> D_STRING .)
    )               reduce using rule 94 (datatype -> D_STRING .)


state 13

    (95) datatype -> D_FLOAT .
    ID              reduce using rule 95 (datatype -> D_FLOAT .)
    ;               reduce using rule 95 (datatype -> D_FLOAT .)
    FUNC            reduce using rule 95 (datatype -> D_FLOAT .)
    ,               reduce using rule 95 (datatype -> D_FLOAT .)
    )               reduce using rule 95 (datatype -> D_FLOAT .)


state 14

    (96) datatype -> D_INT .
    ID              reduce using rule 96 (datatype -> D_INT .)
    ;               reduce using rule 96 (datatype -> D_INT .)
    FUNC            reduce using rule 96 (datatype -> D_INT .)
    ,               reduce using rule 96 (datatype -> D_INT .)
    )               reduce using rule 96 (datatype -> D_INT .)


state 15

    (1) program -> PROG ID check_program ; gvars store_gvars functions . gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
    VAR             shift and go to state 7
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 19

state 16

    (19) functions -> datatype . FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    FUNC            shift and go to state 20


state 17

    (2) gvars -> VAR datatype gvarids . store_gtype ; gvars
    (8) store_gtype -> .
    ;               reduce using rule 8 (store_gtype -> .)

    store_gtype                    shift and go to state 21

state 18

    (4) gvarids -> ID .
    (5) gvarids -> ID . , gvarids
    ;               reduce using rule 4 (gvarids -> ID .)
    ,               shift and go to state 22


state 19

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars . store_gvars main
    (7) store_gvars -> .
    FUNC            reduce using rule 7 (store_gvars -> .)

    store_gvars                    shift and go to state 23

state 20

    (19) functions -> datatype FUNC . ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    ID              shift and go to state 24


state 21

    (2) gvars -> VAR datatype gvarids store_gtype . ; gvars
    ;               shift and go to state 25


state 22

    (5) gvarids -> ID , . gvarids
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    (6) gvarids -> .
    ID              shift and go to state 18
    ;               reduce using rule 6 (gvarids -> .)

    gvarids                        shift and go to state 26

state 23

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars . main
    (26) main -> . FUNC MAIN ( ) store_funcm { vars store_mainv maincontent }
    FUNC            shift and go to state 28

    main                           shift and go to state 27

state 24

    (19) functions -> datatype FUNC ID . ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (               shift and go to state 29


state 25

    (2) gvars -> VAR datatype gvarids store_gtype ; . gvars
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    VOID            reduce using rule 3 (gvars -> .)
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 30

state 26

    (5) gvarids -> ID , gvarids .
    ;               reduce using rule 5 (gvarids -> ID , gvarids .)


state 27

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .
    $end            reduce using rule 1 (program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .)


state 28

    (26) main -> FUNC . MAIN ( ) store_funcm { vars store_mainv maincontent }
    MAIN            shift and go to state 31


state 29

    (19) functions -> datatype FUNC ID ( . params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (23) params -> . ID : datatype , params
    (24) params -> . ID : datatype
    (25) params -> .
    ID              shift and go to state 32
    )               reduce using rule 25 (params -> .)

    params                         shift and go to state 33

state 30

    (2) gvars -> VAR datatype gvarids store_gtype ; gvars .
    VOID            reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_BOOL          reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_STRING        reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_FLOAT         reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_INT           reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    VAR             reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    FUNC            reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)


state 31

    (26) main -> FUNC MAIN . ( ) store_funcm { vars store_mainv maincontent }
    (               shift and go to state 34


state 32

    (23) params -> ID . : datatype , params
    (24) params -> ID . : datatype
    :               shift and go to state 35


state 33

    (19) functions -> datatype FUNC ID ( params . ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    )               shift and go to state 36


state 34

    (26) main -> FUNC MAIN ( . ) store_funcm { vars store_mainv maincontent }
    )               shift and go to state 37


state 35

    (23) params -> ID : . datatype , params
    (24) params -> ID : . datatype
    (92) datatype -> . VOID
    (93) datatype -> . D_BOOL
    (94) datatype -> . D_STRING
    (95) datatype -> . D_FLOAT
    (96) datatype -> . D_INT
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 38

state 36

    (19) functions -> datatype FUNC ID ( params ) . store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (100) store_funcv -> .
    {               reduce using rule 100 (store_funcv -> .)

    store_funcv                    shift and go to state 39

state 37

    (26) main -> FUNC MAIN ( ) . store_funcm { vars store_mainv maincontent }
    (99) store_funcm -> .
    {               reduce using rule 99 (store_funcm -> .)

    store_funcm                    shift and go to state 40

state 38

    (23) params -> ID : datatype . , params
    (24) params -> ID : datatype .
    ,               shift and go to state 41
    )               reduce using rule 24 (params -> ID : datatype .)


state 39

    (19) functions -> datatype FUNC ID ( params ) store_funcv . store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (101) store_params -> .
    {               reduce using rule 101 (store_params -> .)

    store_params                   shift and go to state 42

state 40

    (26) main -> FUNC MAIN ( ) store_funcm . { vars store_mainv maincontent }
    {               shift and go to state 43


state 41

    (23) params -> ID : datatype , . params
    (23) params -> . ID : datatype , params
    (24) params -> . ID : datatype
    (25) params -> .
    ID              shift and go to state 32
    )               reduce using rule 25 (params -> .)

    params                         shift and go to state 44

state 42

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params . store_init_quad { vars store_local_vars funcontent } close_func functions
    (98) store_init_quad -> .
    {               reduce using rule 98 (store_init_quad -> .)

    store_init_quad                shift and go to state 45

state 43

    (26) main -> FUNC MAIN ( ) store_funcm { . vars store_mainv maincontent }
    (9) vars -> . VAR datatype varids store_type ; vars
    (10) vars -> .
    VAR             shift and go to state 47
    WHILE           reduce using rule 10 (vars -> .)
    INPUT           reduce using rule 10 (vars -> .)
    OUTPUT          reduce using rule 10 (vars -> .)
    IF              reduce using rule 10 (vars -> .)
    RETURN          reduce using rule 10 (vars -> .)
    ID              reduce using rule 10 (vars -> .)
    (               reduce using rule 10 (vars -> .)
    STRING          reduce using rule 10 (vars -> .)
    FLOAT           reduce using rule 10 (vars -> .)
    INT             reduce using rule 10 (vars -> .)
    FALSE           reduce using rule 10 (vars -> .)
    TRUE            reduce using rule 10 (vars -> .)
    }               reduce using rule 10 (vars -> .)

    vars                           shift and go to state 46

state 44

    (23) params -> ID : datatype , params .
    )               reduce using rule 23 (params -> ID : datatype , params .)


state 45

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad . { vars store_local_vars funcontent } close_func functions
    {               shift and go to state 48


state 46

    (26) main -> FUNC MAIN ( ) store_funcm { vars . store_mainv maincontent }
    (103) store_mainv -> .
    WHILE           reduce using rule 103 (store_mainv -> .)
    INPUT           reduce using rule 103 (store_mainv -> .)
    OUTPUT          reduce using rule 103 (store_mainv -> .)
    IF              reduce using rule 103 (store_mainv -> .)
    RETURN          reduce using rule 103 (store_mainv -> .)
    ID              reduce using rule 103 (store_mainv -> .)
    (               reduce using rule 103 (store_mainv -> .)
    STRING          reduce using rule 103 (store_mainv -> .)
    FLOAT           reduce using rule 103 (store_mainv -> .)
    INT             reduce using rule 103 (store_mainv -> .)
    FALSE           reduce using rule 103 (store_mainv -> .)
    TRUE            reduce using rule 103 (store_mainv -> .)
    }               reduce using rule 103 (store_mainv -> .)

    store_mainv                    shift and go to state 49

state 47

    (9) vars -> VAR . datatype varids store_type ; vars
    (92) datatype -> . VOID
    (93) datatype -> . D_BOOL
    (94) datatype -> . D_STRING
    (95) datatype -> . D_FLOAT
    (96) datatype -> . D_INT
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 50

state 48

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { . vars store_local_vars funcontent } close_func functions
    (9) vars -> . VAR datatype varids store_type ; vars
    (10) vars -> .
    VAR             shift and go to state 47
    WHILE           reduce using rule 10 (vars -> .)
    INPUT           reduce using rule 10 (vars -> .)
    OUTPUT          reduce using rule 10 (vars -> .)
    IF              reduce using rule 10 (vars -> .)
    RETURN          reduce using rule 10 (vars -> .)
    ID              reduce using rule 10 (vars -> .)
    (               reduce using rule 10 (vars -> .)
    STRING          reduce using rule 10 (vars -> .)
    FLOAT           reduce using rule 10 (vars -> .)
    INT             reduce using rule 10 (vars -> .)
    FALSE           reduce using rule 10 (vars -> .)
    TRUE            reduce using rule 10 (vars -> .)
    }               reduce using rule 10 (vars -> .)

    vars                           shift and go to state 51

state 49

    (26) main -> FUNC MAIN ( ) store_funcm { vars store_mainv . maincontent }
    (27) maincontent -> .
    (28) maincontent -> . statement maincontent
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 27 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 27 (maincontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    maincontent                    shift and go to state 53
    statement                      shift and go to state 54
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 50

    (9) vars -> VAR datatype . varids store_type ; vars
    (11) varids -> . ID darray
    (12) varids -> . ID darray , varids
    (13) varids -> .
    ID              shift and go to state 83
    ;               reduce using rule 13 (varids -> .)

    varids                         shift and go to state 82

state 51

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars . store_local_vars funcontent } close_func functions
    (102) store_local_vars -> .
    WHILE           reduce using rule 102 (store_local_vars -> .)
    INPUT           reduce using rule 102 (store_local_vars -> .)
    OUTPUT          reduce using rule 102 (store_local_vars -> .)
    IF              reduce using rule 102 (store_local_vars -> .)
    RETURN          reduce using rule 102 (store_local_vars -> .)
    ID              reduce using rule 102 (store_local_vars -> .)
    (               reduce using rule 102 (store_local_vars -> .)
    STRING          reduce using rule 102 (store_local_vars -> .)
    FLOAT           reduce using rule 102 (store_local_vars -> .)
    INT             reduce using rule 102 (store_local_vars -> .)
    FALSE           reduce using rule 102 (store_local_vars -> .)
    TRUE            reduce using rule 102 (store_local_vars -> .)
    }               reduce using rule 102 (store_local_vars -> .)

    store_local_vars               shift and go to state 84

state 52

    (73) factor -> ( . store_op expr ) store_op
    (104) store_op -> .
    (               reduce using rule 104 (store_op -> .)
    ID              reduce using rule 104 (store_op -> .)
    STRING          reduce using rule 104 (store_op -> .)
    FLOAT           reduce using rule 104 (store_op -> .)
    INT             reduce using rule 104 (store_op -> .)
    FALSE           reduce using rule 104 (store_op -> .)
    TRUE            reduce using rule 104 (store_op -> .)

    store_op                       shift and go to state 85

state 53

    (26) main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent . }
    }               shift and go to state 86


state 54

    (28) maincontent -> statement . maincontent
    (37) statement -> statement . statement
    (27) maincontent -> .
    (28) maincontent -> . statement maincontent
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 27 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 27 (maincontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    statement                      shift and go to state 87
    maincontent                    shift and go to state 88
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 55

    (29) statement -> loop . unload_pv
    (107) unload_pv -> .
    WHILE           reduce using rule 107 (unload_pv -> .)
    INPUT           reduce using rule 107 (unload_pv -> .)
    OUTPUT          reduce using rule 107 (unload_pv -> .)
    IF              reduce using rule 107 (unload_pv -> .)
    RETURN          reduce using rule 107 (unload_pv -> .)
    ID              reduce using rule 107 (unload_pv -> .)
    (               reduce using rule 107 (unload_pv -> .)
    STRING          reduce using rule 107 (unload_pv -> .)
    FLOAT           reduce using rule 107 (unload_pv -> .)
    INT             reduce using rule 107 (unload_pv -> .)
    FALSE           reduce using rule 107 (unload_pv -> .)
    TRUE            reduce using rule 107 (unload_pv -> .)
    }               reduce using rule 107 (unload_pv -> .)

    unload_pv                      shift and go to state 89

state 56

    (30) statement -> input . unload_pv
    (107) unload_pv -> .
    WHILE           reduce using rule 107 (unload_pv -> .)
    INPUT           reduce using rule 107 (unload_pv -> .)
    OUTPUT          reduce using rule 107 (unload_pv -> .)
    IF              reduce using rule 107 (unload_pv -> .)
    RETURN          reduce using rule 107 (unload_pv -> .)
    ID              reduce using rule 107 (unload_pv -> .)
    (               reduce using rule 107 (unload_pv -> .)
    STRING          reduce using rule 107 (unload_pv -> .)
    FLOAT           reduce using rule 107 (unload_pv -> .)
    INT             reduce using rule 107 (unload_pv -> .)
    FALSE           reduce using rule 107 (unload_pv -> .)
    TRUE            reduce using rule 107 (unload_pv -> .)
    }               reduce using rule 107 (unload_pv -> .)

    unload_pv                      shift and go to state 90

state 57

    (31) statement -> output . unload_pv
    (107) unload_pv -> .
    WHILE           reduce using rule 107 (unload_pv -> .)
    INPUT           reduce using rule 107 (unload_pv -> .)
    OUTPUT          reduce using rule 107 (unload_pv -> .)
    IF              reduce using rule 107 (unload_pv -> .)
    RETURN          reduce using rule 107 (unload_pv -> .)
    ID              reduce using rule 107 (unload_pv -> .)
    (               reduce using rule 107 (unload_pv -> .)
    STRING          reduce using rule 107 (unload_pv -> .)
    FLOAT           reduce using rule 107 (unload_pv -> .)
    INT             reduce using rule 107 (unload_pv -> .)
    FALSE           reduce using rule 107 (unload_pv -> .)
    TRUE            reduce using rule 107 (unload_pv -> .)
    }               reduce using rule 107 (unload_pv -> .)

    unload_pv                      shift and go to state 91

state 58

    (32) statement -> ifelse . unload_pv
    (107) unload_pv -> .
    WHILE           reduce using rule 107 (unload_pv -> .)
    INPUT           reduce using rule 107 (unload_pv -> .)
    OUTPUT          reduce using rule 107 (unload_pv -> .)
    IF              reduce using rule 107 (unload_pv -> .)
    RETURN          reduce using rule 107 (unload_pv -> .)
    ID              reduce using rule 107 (unload_pv -> .)
    (               reduce using rule 107 (unload_pv -> .)
    STRING          reduce using rule 107 (unload_pv -> .)
    FLOAT           reduce using rule 107 (unload_pv -> .)
    INT             reduce using rule 107 (unload_pv -> .)
    FALSE           reduce using rule 107 (unload_pv -> .)
    TRUE            reduce using rule 107 (unload_pv -> .)
    }               reduce using rule 107 (unload_pv -> .)

    unload_pv                      shift and go to state 92

state 59

    (33) statement -> returns . unload_pv ;
    (107) unload_pv -> .
    ;               reduce using rule 107 (unload_pv -> .)

    unload_pv                      shift and go to state 93

state 60

    (34) statement -> expr . ;
    ;               shift and go to state 94


state 61

    (35) statement -> var_assign . unload_pv
    (107) unload_pv -> .
    WHILE           reduce using rule 107 (unload_pv -> .)
    INPUT           reduce using rule 107 (unload_pv -> .)
    OUTPUT          reduce using rule 107 (unload_pv -> .)
    IF              reduce using rule 107 (unload_pv -> .)
    RETURN          reduce using rule 107 (unload_pv -> .)
    ID              reduce using rule 107 (unload_pv -> .)
    (               reduce using rule 107 (unload_pv -> .)
    STRING          reduce using rule 107 (unload_pv -> .)
    FLOAT           reduce using rule 107 (unload_pv -> .)
    INT             reduce using rule 107 (unload_pv -> .)
    FALSE           reduce using rule 107 (unload_pv -> .)
    TRUE            reduce using rule 107 (unload_pv -> .)
    }               reduce using rule 107 (unload_pv -> .)

    unload_pv                      shift and go to state 95

state 62

    (50) loop -> WHILE . store_jump ( expr ) store_gotof { statement } end_loop
    (120) store_jump -> .
    (               reduce using rule 120 (store_jump -> .)

    store_jump                     shift and go to state 96

state 63

    (49) input -> INPUT . ( ID store_oper ) ;
    (               shift and go to state 97


state 64

    (40) var_assign -> ID . store_oper = idarray ;
    (42) var_assign -> ID . store_oper = expr ;
    (90) idarray -> ID . [ add_fstack expr end_fstack ]
    (85) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (79) compoundx -> ID . store_oper
    (105) store_oper -> .
    (115) verify_func -> .
    [               shift and go to state 99
    =               reduce using rule 105 (store_oper -> .)
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    ;               reduce using rule 105 (store_oper -> .)
    (               reduce using rule 115 (verify_func -> .)

    store_oper                     shift and go to state 98
    verify_func                    shift and go to state 100

state 65

    (46) output -> OUTPUT . ( expr outex ) ;
    (               shift and go to state 101


state 66

    (44) ifelse -> IF . ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> IF . ( expr ) store_gotof { statement } store_endif
    (               shift and go to state 102


state 67

    (43) returns -> RETURN . expr store_rquad
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 103
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 68

    (51) expr -> arexp . exprx
    (52) exprx -> .
    (53) exprx -> . exprop arexp
    (54) exprop -> . OR
    (55) exprop -> . EQEQ
    (56) exprop -> . DIFF
    (57) exprop -> . AND
    (58) exprop -> . <
    (59) exprop -> . LOETHAN
    (60) exprop -> . >
    (61) exprop -> . GOETHAN
    ;               reduce using rule 52 (exprx -> .)
    )               reduce using rule 52 (exprx -> .)
    ,               reduce using rule 52 (exprx -> .)
    ]               reduce using rule 52 (exprx -> .)
    OR              shift and go to state 108
    EQEQ            shift and go to state 109
    DIFF            shift and go to state 110
    AND             shift and go to state 111
    <               shift and go to state 112
    LOETHAN         shift and go to state 113
    >               shift and go to state 114
    GOETHAN         shift and go to state 115

    exprx                          shift and go to state 106
    exprop                         shift and go to state 107

state 69

    (38) var_assign -> idarray . store_oper = expr ;
    (39) var_assign -> idarray . store_oper = ID store_oper ;
    (41) var_assign -> idarray . store_oper = idarray store_oper ;
    (74) element -> idarray . store_oper
    (105) store_oper -> .
    =               reduce using rule 105 (store_oper -> .)
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    ;               reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 116

state 70

    (62) arexp -> term . arexpextra
    (63) arexp -> term .
    (64) arexpextra -> .
    (65) arexpextra -> . - term arexpextra
    (66) arexpextra -> . + term arexpextra
  ! reduce/reduce conflict for OR resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for EQEQ resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for DIFF resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for AND resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for < resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for > resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for ; resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for ) resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for , resolved using rule 63 (arexp -> term .)
  ! reduce/reduce conflict for ] resolved using rule 63 (arexp -> term .)
    OR              reduce using rule 63 (arexp -> term .)
    EQEQ            reduce using rule 63 (arexp -> term .)
    DIFF            reduce using rule 63 (arexp -> term .)
    AND             reduce using rule 63 (arexp -> term .)
    <               reduce using rule 63 (arexp -> term .)
    LOETHAN         reduce using rule 63 (arexp -> term .)
    >               reduce using rule 63 (arexp -> term .)
    GOETHAN         reduce using rule 63 (arexp -> term .)
    ;               reduce using rule 63 (arexp -> term .)
    )               reduce using rule 63 (arexp -> term .)
    ,               reduce using rule 63 (arexp -> term .)
    ]               reduce using rule 63 (arexp -> term .)
    -               shift and go to state 118
    +               shift and go to state 119

    arexpextra                     shift and go to state 117

state 71

    (67) term -> factor . termx
    (68) term -> factor .
    (69) termx -> .
    (70) termx -> . / factor termx
    (71) termx -> . * factor termx
  ! reduce/reduce conflict for - resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for + resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for OR resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for EQEQ resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for DIFF resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for AND resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for < resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for > resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for ; resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for ) resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for , resolved using rule 68 (term -> factor .)
  ! reduce/reduce conflict for ] resolved using rule 68 (term -> factor .)
    -               reduce using rule 68 (term -> factor .)
    +               reduce using rule 68 (term -> factor .)
    OR              reduce using rule 68 (term -> factor .)
    EQEQ            reduce using rule 68 (term -> factor .)
    DIFF            reduce using rule 68 (term -> factor .)
    AND             reduce using rule 68 (term -> factor .)
    <               reduce using rule 68 (term -> factor .)
    LOETHAN         reduce using rule 68 (term -> factor .)
    >               reduce using rule 68 (term -> factor .)
    GOETHAN         reduce using rule 68 (term -> factor .)
    ;               reduce using rule 68 (term -> factor .)
    )               reduce using rule 68 (term -> factor .)
    ,               reduce using rule 68 (term -> factor .)
    ]               reduce using rule 68 (term -> factor .)
    /               shift and go to state 121
    *               shift and go to state 122

    termx                          shift and go to state 120

state 72

    (72) factor -> element .
    /               reduce using rule 72 (factor -> element .)
    *               reduce using rule 72 (factor -> element .)
    -               reduce using rule 72 (factor -> element .)
    +               reduce using rule 72 (factor -> element .)
    OR              reduce using rule 72 (factor -> element .)
    EQEQ            reduce using rule 72 (factor -> element .)
    DIFF            reduce using rule 72 (factor -> element .)
    AND             reduce using rule 72 (factor -> element .)
    <               reduce using rule 72 (factor -> element .)
    LOETHAN         reduce using rule 72 (factor -> element .)
    >               reduce using rule 72 (factor -> element .)
    GOETHAN         reduce using rule 72 (factor -> element .)
    ;               reduce using rule 72 (factor -> element .)
    )               reduce using rule 72 (factor -> element .)
    ,               reduce using rule 72 (factor -> element .)
    ]               reduce using rule 72 (factor -> element .)


state 73

    (75) element -> callfunc . store_oper
    (105) store_oper -> .
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    ;               reduce using rule 105 (store_oper -> .)
    )               reduce using rule 105 (store_oper -> .)
    ,               reduce using rule 105 (store_oper -> .)
    ]               reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 123

state 74

    (76) element -> compound . store_oper
    (105) store_oper -> .
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    ;               reduce using rule 105 (store_oper -> .)
    )               reduce using rule 105 (store_oper -> .)
    ,               reduce using rule 105 (store_oper -> .)
    ]               reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 124

state 75

    (77) element -> const . store_const
    (106) store_const -> .
    /               reduce using rule 106 (store_const -> .)
    *               reduce using rule 106 (store_const -> .)
    -               reduce using rule 106 (store_const -> .)
    +               reduce using rule 106 (store_const -> .)
    OR              reduce using rule 106 (store_const -> .)
    EQEQ            reduce using rule 106 (store_const -> .)
    DIFF            reduce using rule 106 (store_const -> .)
    AND             reduce using rule 106 (store_const -> .)
    <               reduce using rule 106 (store_const -> .)
    LOETHAN         reduce using rule 106 (store_const -> .)
    >               reduce using rule 106 (store_const -> .)
    GOETHAN         reduce using rule 106 (store_const -> .)
    ;               reduce using rule 106 (store_const -> .)
    )               reduce using rule 106 (store_const -> .)
    ,               reduce using rule 106 (store_const -> .)
    ]               reduce using rule 106 (store_const -> .)

    store_const                    shift and go to state 125

state 76

    (78) compound -> compoundx .
    /               reduce using rule 78 (compound -> compoundx .)
    *               reduce using rule 78 (compound -> compoundx .)
    -               reduce using rule 78 (compound -> compoundx .)
    +               reduce using rule 78 (compound -> compoundx .)
    OR              reduce using rule 78 (compound -> compoundx .)
    EQEQ            reduce using rule 78 (compound -> compoundx .)
    DIFF            reduce using rule 78 (compound -> compoundx .)
    AND             reduce using rule 78 (compound -> compoundx .)
    <               reduce using rule 78 (compound -> compoundx .)
    LOETHAN         reduce using rule 78 (compound -> compoundx .)
    >               reduce using rule 78 (compound -> compoundx .)
    GOETHAN         reduce using rule 78 (compound -> compoundx .)
    ;               reduce using rule 78 (compound -> compoundx .)
    )               reduce using rule 78 (compound -> compoundx .)
    ,               reduce using rule 78 (compound -> compoundx .)
    ]               reduce using rule 78 (compound -> compoundx .)


state 77

    (80) const -> STRING .
    /               reduce using rule 80 (const -> STRING .)
    *               reduce using rule 80 (const -> STRING .)
    -               reduce using rule 80 (const -> STRING .)
    +               reduce using rule 80 (const -> STRING .)
    OR              reduce using rule 80 (const -> STRING .)
    EQEQ            reduce using rule 80 (const -> STRING .)
    DIFF            reduce using rule 80 (const -> STRING .)
    AND             reduce using rule 80 (const -> STRING .)
    <               reduce using rule 80 (const -> STRING .)
    LOETHAN         reduce using rule 80 (const -> STRING .)
    >               reduce using rule 80 (const -> STRING .)
    GOETHAN         reduce using rule 80 (const -> STRING .)
    ;               reduce using rule 80 (const -> STRING .)
    )               reduce using rule 80 (const -> STRING .)
    ,               reduce using rule 80 (const -> STRING .)
    ]               reduce using rule 80 (const -> STRING .)


state 78

    (81) const -> FLOAT .
    /               reduce using rule 81 (const -> FLOAT .)
    *               reduce using rule 81 (const -> FLOAT .)
    -               reduce using rule 81 (const -> FLOAT .)
    +               reduce using rule 81 (const -> FLOAT .)
    OR              reduce using rule 81 (const -> FLOAT .)
    EQEQ            reduce using rule 81 (const -> FLOAT .)
    DIFF            reduce using rule 81 (const -> FLOAT .)
    AND             reduce using rule 81 (const -> FLOAT .)
    <               reduce using rule 81 (const -> FLOAT .)
    LOETHAN         reduce using rule 81 (const -> FLOAT .)
    >               reduce using rule 81 (const -> FLOAT .)
    GOETHAN         reduce using rule 81 (const -> FLOAT .)
    ;               reduce using rule 81 (const -> FLOAT .)
    )               reduce using rule 81 (const -> FLOAT .)
    ,               reduce using rule 81 (const -> FLOAT .)
    ]               reduce using rule 81 (const -> FLOAT .)


state 79

    (82) const -> INT .
    /               reduce using rule 82 (const -> INT .)
    *               reduce using rule 82 (const -> INT .)
    -               reduce using rule 82 (const -> INT .)
    +               reduce using rule 82 (const -> INT .)
    OR              reduce using rule 82 (const -> INT .)
    EQEQ            reduce using rule 82 (const -> INT .)
    DIFF            reduce using rule 82 (const -> INT .)
    AND             reduce using rule 82 (const -> INT .)
    <               reduce using rule 82 (const -> INT .)
    LOETHAN         reduce using rule 82 (const -> INT .)
    >               reduce using rule 82 (const -> INT .)
    GOETHAN         reduce using rule 82 (const -> INT .)
    ;               reduce using rule 82 (const -> INT .)
    )               reduce using rule 82 (const -> INT .)
    ,               reduce using rule 82 (const -> INT .)
    ]               reduce using rule 82 (const -> INT .)


state 80

    (83) const -> FALSE .
    /               reduce using rule 83 (const -> FALSE .)
    *               reduce using rule 83 (const -> FALSE .)
    -               reduce using rule 83 (const -> FALSE .)
    +               reduce using rule 83 (const -> FALSE .)
    OR              reduce using rule 83 (const -> FALSE .)
    EQEQ            reduce using rule 83 (const -> FALSE .)
    DIFF            reduce using rule 83 (const -> FALSE .)
    AND             reduce using rule 83 (const -> FALSE .)
    <               reduce using rule 83 (const -> FALSE .)
    LOETHAN         reduce using rule 83 (const -> FALSE .)
    >               reduce using rule 83 (const -> FALSE .)
    GOETHAN         reduce using rule 83 (const -> FALSE .)
    ;               reduce using rule 83 (const -> FALSE .)
    )               reduce using rule 83 (const -> FALSE .)
    ,               reduce using rule 83 (const -> FALSE .)
    ]               reduce using rule 83 (const -> FALSE .)


state 81

    (84) const -> TRUE .
    /               reduce using rule 84 (const -> TRUE .)
    *               reduce using rule 84 (const -> TRUE .)
    -               reduce using rule 84 (const -> TRUE .)
    +               reduce using rule 84 (const -> TRUE .)
    OR              reduce using rule 84 (const -> TRUE .)
    EQEQ            reduce using rule 84 (const -> TRUE .)
    DIFF            reduce using rule 84 (const -> TRUE .)
    AND             reduce using rule 84 (const -> TRUE .)
    <               reduce using rule 84 (const -> TRUE .)
    LOETHAN         reduce using rule 84 (const -> TRUE .)
    >               reduce using rule 84 (const -> TRUE .)
    GOETHAN         reduce using rule 84 (const -> TRUE .)
    ;               reduce using rule 84 (const -> TRUE .)
    )               reduce using rule 84 (const -> TRUE .)
    ,               reduce using rule 84 (const -> TRUE .)
    ]               reduce using rule 84 (const -> TRUE .)


state 82

    (9) vars -> VAR datatype varids . store_type ; vars
    (14) store_type -> .
    ;               reduce using rule 14 (store_type -> .)

    store_type                     shift and go to state 126

state 83

    (11) varids -> ID . darray
    (12) varids -> ID . darray , varids
    (15) darray -> .
    (16) darray -> . [ INT ] twodarray
    ,               reduce using rule 15 (darray -> .)
    ;               reduce using rule 15 (darray -> .)
    [               shift and go to state 128

    darray                         shift and go to state 127

state 84

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars . funcontent } close_func functions
    (21) funcontent -> .
    (22) funcontent -> . statement funcontent
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 21 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 21 (funcontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    funcontent                     shift and go to state 129
    statement                      shift and go to state 130
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 85

    (73) factor -> ( store_op . expr ) store_op
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 131
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 86

    (26) main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent } .
    $end            reduce using rule 26 (main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent } .)


state 87

    (37) statement -> statement statement .
    (28) maincontent -> statement . maincontent
    (37) statement -> statement . statement
    (27) maincontent -> .
    (28) maincontent -> . statement maincontent
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 27 (maincontent -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for INPUT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for IF resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for ID resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for ( resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for STRING resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for } resolved using rule 27 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 27 (maincontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    statement                      shift and go to state 87
    maincontent                    shift and go to state 88
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 88

    (28) maincontent -> statement maincontent .
    }               reduce using rule 28 (maincontent -> statement maincontent .)


state 89

    (29) statement -> loop unload_pv .
    WHILE           reduce using rule 29 (statement -> loop unload_pv .)
    INPUT           reduce using rule 29 (statement -> loop unload_pv .)
    OUTPUT          reduce using rule 29 (statement -> loop unload_pv .)
    IF              reduce using rule 29 (statement -> loop unload_pv .)
    RETURN          reduce using rule 29 (statement -> loop unload_pv .)
    ID              reduce using rule 29 (statement -> loop unload_pv .)
    (               reduce using rule 29 (statement -> loop unload_pv .)
    STRING          reduce using rule 29 (statement -> loop unload_pv .)
    FLOAT           reduce using rule 29 (statement -> loop unload_pv .)
    INT             reduce using rule 29 (statement -> loop unload_pv .)
    FALSE           reduce using rule 29 (statement -> loop unload_pv .)
    TRUE            reduce using rule 29 (statement -> loop unload_pv .)
    }               reduce using rule 29 (statement -> loop unload_pv .)


state 90

    (30) statement -> input unload_pv .
    WHILE           reduce using rule 30 (statement -> input unload_pv .)
    INPUT           reduce using rule 30 (statement -> input unload_pv .)
    OUTPUT          reduce using rule 30 (statement -> input unload_pv .)
    IF              reduce using rule 30 (statement -> input unload_pv .)
    RETURN          reduce using rule 30 (statement -> input unload_pv .)
    ID              reduce using rule 30 (statement -> input unload_pv .)
    (               reduce using rule 30 (statement -> input unload_pv .)
    STRING          reduce using rule 30 (statement -> input unload_pv .)
    FLOAT           reduce using rule 30 (statement -> input unload_pv .)
    INT             reduce using rule 30 (statement -> input unload_pv .)
    FALSE           reduce using rule 30 (statement -> input unload_pv .)
    TRUE            reduce using rule 30 (statement -> input unload_pv .)
    }               reduce using rule 30 (statement -> input unload_pv .)


state 91

    (31) statement -> output unload_pv .
    WHILE           reduce using rule 31 (statement -> output unload_pv .)
    INPUT           reduce using rule 31 (statement -> output unload_pv .)
    OUTPUT          reduce using rule 31 (statement -> output unload_pv .)
    IF              reduce using rule 31 (statement -> output unload_pv .)
    RETURN          reduce using rule 31 (statement -> output unload_pv .)
    ID              reduce using rule 31 (statement -> output unload_pv .)
    (               reduce using rule 31 (statement -> output unload_pv .)
    STRING          reduce using rule 31 (statement -> output unload_pv .)
    FLOAT           reduce using rule 31 (statement -> output unload_pv .)
    INT             reduce using rule 31 (statement -> output unload_pv .)
    FALSE           reduce using rule 31 (statement -> output unload_pv .)
    TRUE            reduce using rule 31 (statement -> output unload_pv .)
    }               reduce using rule 31 (statement -> output unload_pv .)


state 92

    (32) statement -> ifelse unload_pv .
    WHILE           reduce using rule 32 (statement -> ifelse unload_pv .)
    INPUT           reduce using rule 32 (statement -> ifelse unload_pv .)
    OUTPUT          reduce using rule 32 (statement -> ifelse unload_pv .)
    IF              reduce using rule 32 (statement -> ifelse unload_pv .)
    RETURN          reduce using rule 32 (statement -> ifelse unload_pv .)
    ID              reduce using rule 32 (statement -> ifelse unload_pv .)
    (               reduce using rule 32 (statement -> ifelse unload_pv .)
    STRING          reduce using rule 32 (statement -> ifelse unload_pv .)
    FLOAT           reduce using rule 32 (statement -> ifelse unload_pv .)
    INT             reduce using rule 32 (statement -> ifelse unload_pv .)
    FALSE           reduce using rule 32 (statement -> ifelse unload_pv .)
    TRUE            reduce using rule 32 (statement -> ifelse unload_pv .)
    }               reduce using rule 32 (statement -> ifelse unload_pv .)


state 93

    (33) statement -> returns unload_pv . ;
    ;               shift and go to state 132


state 94

    (34) statement -> expr ; .
    WHILE           reduce using rule 34 (statement -> expr ; .)
    INPUT           reduce using rule 34 (statement -> expr ; .)
    OUTPUT          reduce using rule 34 (statement -> expr ; .)
    IF              reduce using rule 34 (statement -> expr ; .)
    RETURN          reduce using rule 34 (statement -> expr ; .)
    ID              reduce using rule 34 (statement -> expr ; .)
    (               reduce using rule 34 (statement -> expr ; .)
    STRING          reduce using rule 34 (statement -> expr ; .)
    FLOAT           reduce using rule 34 (statement -> expr ; .)
    INT             reduce using rule 34 (statement -> expr ; .)
    FALSE           reduce using rule 34 (statement -> expr ; .)
    TRUE            reduce using rule 34 (statement -> expr ; .)
    }               reduce using rule 34 (statement -> expr ; .)


state 95

    (35) statement -> var_assign unload_pv .
    WHILE           reduce using rule 35 (statement -> var_assign unload_pv .)
    INPUT           reduce using rule 35 (statement -> var_assign unload_pv .)
    OUTPUT          reduce using rule 35 (statement -> var_assign unload_pv .)
    IF              reduce using rule 35 (statement -> var_assign unload_pv .)
    RETURN          reduce using rule 35 (statement -> var_assign unload_pv .)
    ID              reduce using rule 35 (statement -> var_assign unload_pv .)
    (               reduce using rule 35 (statement -> var_assign unload_pv .)
    STRING          reduce using rule 35 (statement -> var_assign unload_pv .)
    FLOAT           reduce using rule 35 (statement -> var_assign unload_pv .)
    INT             reduce using rule 35 (statement -> var_assign unload_pv .)
    FALSE           reduce using rule 35 (statement -> var_assign unload_pv .)
    TRUE            reduce using rule 35 (statement -> var_assign unload_pv .)
    }               reduce using rule 35 (statement -> var_assign unload_pv .)


state 96

    (50) loop -> WHILE store_jump . ( expr ) store_gotof { statement } end_loop
    (               shift and go to state 133


state 97

    (49) input -> INPUT ( . ID store_oper ) ;
    ID              shift and go to state 134


state 98

    (40) var_assign -> ID store_oper . = idarray ;
    (42) var_assign -> ID store_oper . = expr ;
    (79) compoundx -> ID store_oper .
    =               shift and go to state 135
    /               reduce using rule 79 (compoundx -> ID store_oper .)
    *               reduce using rule 79 (compoundx -> ID store_oper .)
    -               reduce using rule 79 (compoundx -> ID store_oper .)
    +               reduce using rule 79 (compoundx -> ID store_oper .)
    OR              reduce using rule 79 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 79 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 79 (compoundx -> ID store_oper .)
    AND             reduce using rule 79 (compoundx -> ID store_oper .)
    <               reduce using rule 79 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 79 (compoundx -> ID store_oper .)
    >               reduce using rule 79 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 79 (compoundx -> ID store_oper .)
    ;               reduce using rule 79 (compoundx -> ID store_oper .)


state 99

    (90) idarray -> ID [ . add_fstack expr end_fstack ]
    (116) add_fstack -> .
    (               reduce using rule 116 (add_fstack -> .)
    ID              reduce using rule 116 (add_fstack -> .)
    STRING          reduce using rule 116 (add_fstack -> .)
    FLOAT           reduce using rule 116 (add_fstack -> .)
    INT             reduce using rule 116 (add_fstack -> .)
    FALSE           reduce using rule 116 (add_fstack -> .)
    TRUE            reduce using rule 116 (add_fstack -> .)

    add_fstack                     shift and go to state 136

state 100

    (85) callfunc -> ID verify_func . add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (116) add_fstack -> .
    (               reduce using rule 116 (add_fstack -> .)

    add_fstack                     shift and go to state 137

state 101

    (46) output -> OUTPUT ( . expr outex ) ;
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 138
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 102

    (44) ifelse -> IF ( . expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> IF ( . expr ) store_gotof { statement } store_endif
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 139
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 103

    (43) returns -> RETURN expr . store_rquad
    (108) store_rquad -> .
    ;               reduce using rule 108 (store_rquad -> .)

    store_rquad                    shift and go to state 140

state 104

    (74) element -> idarray . store_oper
    (105) store_oper -> .
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    ;               reduce using rule 105 (store_oper -> .)
    )               reduce using rule 105 (store_oper -> .)
    ,               reduce using rule 105 (store_oper -> .)
    ]               reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 141

state 105

    (90) idarray -> ID . [ add_fstack expr end_fstack ]
    (85) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (79) compoundx -> ID . store_oper
    (115) verify_func -> .
    (105) store_oper -> .
    [               shift and go to state 99
    (               reduce using rule 115 (verify_func -> .)
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    ;               reduce using rule 105 (store_oper -> .)
    )               reduce using rule 105 (store_oper -> .)
    ,               reduce using rule 105 (store_oper -> .)
    ]               reduce using rule 105 (store_oper -> .)

    verify_func                    shift and go to state 100
    store_oper                     shift and go to state 142

state 106

    (51) expr -> arexp exprx .
    ;               reduce using rule 51 (expr -> arexp exprx .)
    )               reduce using rule 51 (expr -> arexp exprx .)
    ,               reduce using rule 51 (expr -> arexp exprx .)
    ]               reduce using rule 51 (expr -> arexp exprx .)


state 107

    (53) exprx -> exprop . arexp
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    arexp                          shift and go to state 143
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 108

    (54) exprop -> OR .
    (               reduce using rule 54 (exprop -> OR .)
    ID              reduce using rule 54 (exprop -> OR .)
    STRING          reduce using rule 54 (exprop -> OR .)
    FLOAT           reduce using rule 54 (exprop -> OR .)
    INT             reduce using rule 54 (exprop -> OR .)
    FALSE           reduce using rule 54 (exprop -> OR .)
    TRUE            reduce using rule 54 (exprop -> OR .)


state 109

    (55) exprop -> EQEQ .
    (               reduce using rule 55 (exprop -> EQEQ .)
    ID              reduce using rule 55 (exprop -> EQEQ .)
    STRING          reduce using rule 55 (exprop -> EQEQ .)
    FLOAT           reduce using rule 55 (exprop -> EQEQ .)
    INT             reduce using rule 55 (exprop -> EQEQ .)
    FALSE           reduce using rule 55 (exprop -> EQEQ .)
    TRUE            reduce using rule 55 (exprop -> EQEQ .)


state 110

    (56) exprop -> DIFF .
    (               reduce using rule 56 (exprop -> DIFF .)
    ID              reduce using rule 56 (exprop -> DIFF .)
    STRING          reduce using rule 56 (exprop -> DIFF .)
    FLOAT           reduce using rule 56 (exprop -> DIFF .)
    INT             reduce using rule 56 (exprop -> DIFF .)
    FALSE           reduce using rule 56 (exprop -> DIFF .)
    TRUE            reduce using rule 56 (exprop -> DIFF .)


state 111

    (57) exprop -> AND .
    (               reduce using rule 57 (exprop -> AND .)
    ID              reduce using rule 57 (exprop -> AND .)
    STRING          reduce using rule 57 (exprop -> AND .)
    FLOAT           reduce using rule 57 (exprop -> AND .)
    INT             reduce using rule 57 (exprop -> AND .)
    FALSE           reduce using rule 57 (exprop -> AND .)
    TRUE            reduce using rule 57 (exprop -> AND .)


state 112

    (58) exprop -> < .
    (               reduce using rule 58 (exprop -> < .)
    ID              reduce using rule 58 (exprop -> < .)
    STRING          reduce using rule 58 (exprop -> < .)
    FLOAT           reduce using rule 58 (exprop -> < .)
    INT             reduce using rule 58 (exprop -> < .)
    FALSE           reduce using rule 58 (exprop -> < .)
    TRUE            reduce using rule 58 (exprop -> < .)


state 113

    (59) exprop -> LOETHAN .
    (               reduce using rule 59 (exprop -> LOETHAN .)
    ID              reduce using rule 59 (exprop -> LOETHAN .)
    STRING          reduce using rule 59 (exprop -> LOETHAN .)
    FLOAT           reduce using rule 59 (exprop -> LOETHAN .)
    INT             reduce using rule 59 (exprop -> LOETHAN .)
    FALSE           reduce using rule 59 (exprop -> LOETHAN .)
    TRUE            reduce using rule 59 (exprop -> LOETHAN .)


state 114

    (60) exprop -> > .
    (               reduce using rule 60 (exprop -> > .)
    ID              reduce using rule 60 (exprop -> > .)
    STRING          reduce using rule 60 (exprop -> > .)
    FLOAT           reduce using rule 60 (exprop -> > .)
    INT             reduce using rule 60 (exprop -> > .)
    FALSE           reduce using rule 60 (exprop -> > .)
    TRUE            reduce using rule 60 (exprop -> > .)


state 115

    (61) exprop -> GOETHAN .
    (               reduce using rule 61 (exprop -> GOETHAN .)
    ID              reduce using rule 61 (exprop -> GOETHAN .)
    STRING          reduce using rule 61 (exprop -> GOETHAN .)
    FLOAT           reduce using rule 61 (exprop -> GOETHAN .)
    INT             reduce using rule 61 (exprop -> GOETHAN .)
    FALSE           reduce using rule 61 (exprop -> GOETHAN .)
    TRUE            reduce using rule 61 (exprop -> GOETHAN .)


state 116

    (38) var_assign -> idarray store_oper . = expr ;
    (39) var_assign -> idarray store_oper . = ID store_oper ;
    (41) var_assign -> idarray store_oper . = idarray store_oper ;
    (74) element -> idarray store_oper .
    =               shift and go to state 144
    /               reduce using rule 74 (element -> idarray store_oper .)
    *               reduce using rule 74 (element -> idarray store_oper .)
    -               reduce using rule 74 (element -> idarray store_oper .)
    +               reduce using rule 74 (element -> idarray store_oper .)
    OR              reduce using rule 74 (element -> idarray store_oper .)
    EQEQ            reduce using rule 74 (element -> idarray store_oper .)
    DIFF            reduce using rule 74 (element -> idarray store_oper .)
    AND             reduce using rule 74 (element -> idarray store_oper .)
    <               reduce using rule 74 (element -> idarray store_oper .)
    LOETHAN         reduce using rule 74 (element -> idarray store_oper .)
    >               reduce using rule 74 (element -> idarray store_oper .)
    GOETHAN         reduce using rule 74 (element -> idarray store_oper .)
    ;               reduce using rule 74 (element -> idarray store_oper .)


state 117

    (62) arexp -> term arexpextra .
    OR              reduce using rule 62 (arexp -> term arexpextra .)
    EQEQ            reduce using rule 62 (arexp -> term arexpextra .)
    DIFF            reduce using rule 62 (arexp -> term arexpextra .)
    AND             reduce using rule 62 (arexp -> term arexpextra .)
    <               reduce using rule 62 (arexp -> term arexpextra .)
    LOETHAN         reduce using rule 62 (arexp -> term arexpextra .)
    >               reduce using rule 62 (arexp -> term arexpextra .)
    GOETHAN         reduce using rule 62 (arexp -> term arexpextra .)
    ;               reduce using rule 62 (arexp -> term arexpextra .)
    )               reduce using rule 62 (arexp -> term arexpextra .)
    ,               reduce using rule 62 (arexp -> term arexpextra .)
    ]               reduce using rule 62 (arexp -> term arexpextra .)


state 118

    (65) arexpextra -> - . term arexpextra
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    term                           shift and go to state 145
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 119

    (66) arexpextra -> + . term arexpextra
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    term                           shift and go to state 146
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 120

    (67) term -> factor termx .
    -               reduce using rule 67 (term -> factor termx .)
    +               reduce using rule 67 (term -> factor termx .)
    OR              reduce using rule 67 (term -> factor termx .)
    EQEQ            reduce using rule 67 (term -> factor termx .)
    DIFF            reduce using rule 67 (term -> factor termx .)
    AND             reduce using rule 67 (term -> factor termx .)
    <               reduce using rule 67 (term -> factor termx .)
    LOETHAN         reduce using rule 67 (term -> factor termx .)
    >               reduce using rule 67 (term -> factor termx .)
    GOETHAN         reduce using rule 67 (term -> factor termx .)
    ;               reduce using rule 67 (term -> factor termx .)
    )               reduce using rule 67 (term -> factor termx .)
    ,               reduce using rule 67 (term -> factor termx .)
    ]               reduce using rule 67 (term -> factor termx .)


state 121

    (70) termx -> / . factor termx
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    factor                         shift and go to state 147
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 122

    (71) termx -> * . factor termx
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    factor                         shift and go to state 148
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 123

    (75) element -> callfunc store_oper .
    /               reduce using rule 75 (element -> callfunc store_oper .)
    *               reduce using rule 75 (element -> callfunc store_oper .)
    -               reduce using rule 75 (element -> callfunc store_oper .)
    +               reduce using rule 75 (element -> callfunc store_oper .)
    OR              reduce using rule 75 (element -> callfunc store_oper .)
    EQEQ            reduce using rule 75 (element -> callfunc store_oper .)
    DIFF            reduce using rule 75 (element -> callfunc store_oper .)
    AND             reduce using rule 75 (element -> callfunc store_oper .)
    <               reduce using rule 75 (element -> callfunc store_oper .)
    LOETHAN         reduce using rule 75 (element -> callfunc store_oper .)
    >               reduce using rule 75 (element -> callfunc store_oper .)
    GOETHAN         reduce using rule 75 (element -> callfunc store_oper .)
    ;               reduce using rule 75 (element -> callfunc store_oper .)
    )               reduce using rule 75 (element -> callfunc store_oper .)
    ,               reduce using rule 75 (element -> callfunc store_oper .)
    ]               reduce using rule 75 (element -> callfunc store_oper .)


state 124

    (76) element -> compound store_oper .
    /               reduce using rule 76 (element -> compound store_oper .)
    *               reduce using rule 76 (element -> compound store_oper .)
    -               reduce using rule 76 (element -> compound store_oper .)
    +               reduce using rule 76 (element -> compound store_oper .)
    OR              reduce using rule 76 (element -> compound store_oper .)
    EQEQ            reduce using rule 76 (element -> compound store_oper .)
    DIFF            reduce using rule 76 (element -> compound store_oper .)
    AND             reduce using rule 76 (element -> compound store_oper .)
    <               reduce using rule 76 (element -> compound store_oper .)
    LOETHAN         reduce using rule 76 (element -> compound store_oper .)
    >               reduce using rule 76 (element -> compound store_oper .)
    GOETHAN         reduce using rule 76 (element -> compound store_oper .)
    ;               reduce using rule 76 (element -> compound store_oper .)
    )               reduce using rule 76 (element -> compound store_oper .)
    ,               reduce using rule 76 (element -> compound store_oper .)
    ]               reduce using rule 76 (element -> compound store_oper .)


state 125

    (77) element -> const store_const .
    /               reduce using rule 77 (element -> const store_const .)
    *               reduce using rule 77 (element -> const store_const .)
    -               reduce using rule 77 (element -> const store_const .)
    +               reduce using rule 77 (element -> const store_const .)
    OR              reduce using rule 77 (element -> const store_const .)
    EQEQ            reduce using rule 77 (element -> const store_const .)
    DIFF            reduce using rule 77 (element -> const store_const .)
    AND             reduce using rule 77 (element -> const store_const .)
    <               reduce using rule 77 (element -> const store_const .)
    LOETHAN         reduce using rule 77 (element -> const store_const .)
    >               reduce using rule 77 (element -> const store_const .)
    GOETHAN         reduce using rule 77 (element -> const store_const .)
    ;               reduce using rule 77 (element -> const store_const .)
    )               reduce using rule 77 (element -> const store_const .)
    ,               reduce using rule 77 (element -> const store_const .)
    ]               reduce using rule 77 (element -> const store_const .)


state 126

    (9) vars -> VAR datatype varids store_type . ; vars
    ;               shift and go to state 149


state 127

    (11) varids -> ID darray .
    (12) varids -> ID darray . , varids
    ;               reduce using rule 11 (varids -> ID darray .)
    ,               shift and go to state 150


state 128

    (16) darray -> [ . INT ] twodarray
    INT             shift and go to state 151


state 129

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent . } close_func functions
    }               shift and go to state 152


state 130

    (22) funcontent -> statement . funcontent
    (37) statement -> statement . statement
    (21) funcontent -> .
    (22) funcontent -> . statement funcontent
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 21 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 21 (funcontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    statement                      shift and go to state 153
    funcontent                     shift and go to state 154
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 131

    (73) factor -> ( store_op expr . ) store_op
    )               shift and go to state 155


state 132

    (33) statement -> returns unload_pv ; .
    WHILE           reduce using rule 33 (statement -> returns unload_pv ; .)
    INPUT           reduce using rule 33 (statement -> returns unload_pv ; .)
    OUTPUT          reduce using rule 33 (statement -> returns unload_pv ; .)
    IF              reduce using rule 33 (statement -> returns unload_pv ; .)
    RETURN          reduce using rule 33 (statement -> returns unload_pv ; .)
    ID              reduce using rule 33 (statement -> returns unload_pv ; .)
    (               reduce using rule 33 (statement -> returns unload_pv ; .)
    STRING          reduce using rule 33 (statement -> returns unload_pv ; .)
    FLOAT           reduce using rule 33 (statement -> returns unload_pv ; .)
    INT             reduce using rule 33 (statement -> returns unload_pv ; .)
    FALSE           reduce using rule 33 (statement -> returns unload_pv ; .)
    TRUE            reduce using rule 33 (statement -> returns unload_pv ; .)
    }               reduce using rule 33 (statement -> returns unload_pv ; .)


state 133

    (50) loop -> WHILE store_jump ( . expr ) store_gotof { statement } end_loop
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 156
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 134

    (49) input -> INPUT ( ID . store_oper ) ;
    (105) store_oper -> .
    )               reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 157

state 135

    (40) var_assign -> ID store_oper = . idarray ;
    (42) var_assign -> ID store_oper = . expr ;
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    ID              shift and go to state 105
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    idarray                        shift and go to state 158
    expr                           shift and go to state 159
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 136

    (90) idarray -> ID [ add_fstack . expr end_fstack ]
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 160
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 137

    (85) callfunc -> ID verify_func add_fstack . ( callfuncpar ver_params ) end_fstack store_gosub
    (               shift and go to state 161


state 138

    (46) output -> OUTPUT ( expr . outex ) ;
    (47) outex -> .
    (48) outex -> . , expr outex
    )               reduce using rule 47 (outex -> .)
    ,               shift and go to state 163

    outex                          shift and go to state 162

state 139

    (44) ifelse -> IF ( expr . ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> IF ( expr . ) store_gotof { statement } store_endif
    )               shift and go to state 164


state 140

    (43) returns -> RETURN expr store_rquad .
    ;               reduce using rule 43 (returns -> RETURN expr store_rquad .)


state 141

    (74) element -> idarray store_oper .
    /               reduce using rule 74 (element -> idarray store_oper .)
    *               reduce using rule 74 (element -> idarray store_oper .)
    -               reduce using rule 74 (element -> idarray store_oper .)
    +               reduce using rule 74 (element -> idarray store_oper .)
    OR              reduce using rule 74 (element -> idarray store_oper .)
    EQEQ            reduce using rule 74 (element -> idarray store_oper .)
    DIFF            reduce using rule 74 (element -> idarray store_oper .)
    AND             reduce using rule 74 (element -> idarray store_oper .)
    <               reduce using rule 74 (element -> idarray store_oper .)
    LOETHAN         reduce using rule 74 (element -> idarray store_oper .)
    >               reduce using rule 74 (element -> idarray store_oper .)
    GOETHAN         reduce using rule 74 (element -> idarray store_oper .)
    ;               reduce using rule 74 (element -> idarray store_oper .)
    )               reduce using rule 74 (element -> idarray store_oper .)
    ,               reduce using rule 74 (element -> idarray store_oper .)
    ]               reduce using rule 74 (element -> idarray store_oper .)


state 142

    (79) compoundx -> ID store_oper .
    /               reduce using rule 79 (compoundx -> ID store_oper .)
    *               reduce using rule 79 (compoundx -> ID store_oper .)
    -               reduce using rule 79 (compoundx -> ID store_oper .)
    +               reduce using rule 79 (compoundx -> ID store_oper .)
    OR              reduce using rule 79 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 79 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 79 (compoundx -> ID store_oper .)
    AND             reduce using rule 79 (compoundx -> ID store_oper .)
    <               reduce using rule 79 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 79 (compoundx -> ID store_oper .)
    >               reduce using rule 79 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 79 (compoundx -> ID store_oper .)
    ;               reduce using rule 79 (compoundx -> ID store_oper .)
    )               reduce using rule 79 (compoundx -> ID store_oper .)
    ,               reduce using rule 79 (compoundx -> ID store_oper .)
    ]               reduce using rule 79 (compoundx -> ID store_oper .)


state 143

    (53) exprx -> exprop arexp .
    ;               reduce using rule 53 (exprx -> exprop arexp .)
    )               reduce using rule 53 (exprx -> exprop arexp .)
    ,               reduce using rule 53 (exprx -> exprop arexp .)
    ]               reduce using rule 53 (exprx -> exprop arexp .)


state 144

    (38) var_assign -> idarray store_oper = . expr ;
    (39) var_assign -> idarray store_oper = . ID store_oper ;
    (41) var_assign -> idarray store_oper = . idarray store_oper ;
    (51) expr -> . arexp exprx
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    ID              shift and go to state 167
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    idarray                        shift and go to state 165
    expr                           shift and go to state 166
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 145

    (65) arexpextra -> - term . arexpextra
    (64) arexpextra -> .
    (65) arexpextra -> . - term arexpextra
    (66) arexpextra -> . + term arexpextra
    OR              reduce using rule 64 (arexpextra -> .)
    EQEQ            reduce using rule 64 (arexpextra -> .)
    DIFF            reduce using rule 64 (arexpextra -> .)
    AND             reduce using rule 64 (arexpextra -> .)
    <               reduce using rule 64 (arexpextra -> .)
    LOETHAN         reduce using rule 64 (arexpextra -> .)
    >               reduce using rule 64 (arexpextra -> .)
    GOETHAN         reduce using rule 64 (arexpextra -> .)
    ;               reduce using rule 64 (arexpextra -> .)
    )               reduce using rule 64 (arexpextra -> .)
    ,               reduce using rule 64 (arexpextra -> .)
    ]               reduce using rule 64 (arexpextra -> .)
    -               shift and go to state 118
    +               shift and go to state 119

    arexpextra                     shift and go to state 168

state 146

    (66) arexpextra -> + term . arexpextra
    (64) arexpextra -> .
    (65) arexpextra -> . - term arexpextra
    (66) arexpextra -> . + term arexpextra
    OR              reduce using rule 64 (arexpextra -> .)
    EQEQ            reduce using rule 64 (arexpextra -> .)
    DIFF            reduce using rule 64 (arexpextra -> .)
    AND             reduce using rule 64 (arexpextra -> .)
    <               reduce using rule 64 (arexpextra -> .)
    LOETHAN         reduce using rule 64 (arexpextra -> .)
    >               reduce using rule 64 (arexpextra -> .)
    GOETHAN         reduce using rule 64 (arexpextra -> .)
    ;               reduce using rule 64 (arexpextra -> .)
    )               reduce using rule 64 (arexpextra -> .)
    ,               reduce using rule 64 (arexpextra -> .)
    ]               reduce using rule 64 (arexpextra -> .)
    -               shift and go to state 118
    +               shift and go to state 119

    arexpextra                     shift and go to state 169

state 147

    (70) termx -> / factor . termx
    (69) termx -> .
    (70) termx -> . / factor termx
    (71) termx -> . * factor termx
    -               reduce using rule 69 (termx -> .)
    +               reduce using rule 69 (termx -> .)
    OR              reduce using rule 69 (termx -> .)
    EQEQ            reduce using rule 69 (termx -> .)
    DIFF            reduce using rule 69 (termx -> .)
    AND             reduce using rule 69 (termx -> .)
    <               reduce using rule 69 (termx -> .)
    LOETHAN         reduce using rule 69 (termx -> .)
    >               reduce using rule 69 (termx -> .)
    GOETHAN         reduce using rule 69 (termx -> .)
    ;               reduce using rule 69 (termx -> .)
    )               reduce using rule 69 (termx -> .)
    ,               reduce using rule 69 (termx -> .)
    ]               reduce using rule 69 (termx -> .)
    /               shift and go to state 121
    *               shift and go to state 122

    termx                          shift and go to state 170

state 148

    (71) termx -> * factor . termx
    (69) termx -> .
    (70) termx -> . / factor termx
    (71) termx -> . * factor termx
    -               reduce using rule 69 (termx -> .)
    +               reduce using rule 69 (termx -> .)
    OR              reduce using rule 69 (termx -> .)
    EQEQ            reduce using rule 69 (termx -> .)
    DIFF            reduce using rule 69 (termx -> .)
    AND             reduce using rule 69 (termx -> .)
    <               reduce using rule 69 (termx -> .)
    LOETHAN         reduce using rule 69 (termx -> .)
    >               reduce using rule 69 (termx -> .)
    GOETHAN         reduce using rule 69 (termx -> .)
    ;               reduce using rule 69 (termx -> .)
    )               reduce using rule 69 (termx -> .)
    ,               reduce using rule 69 (termx -> .)
    ]               reduce using rule 69 (termx -> .)
    /               shift and go to state 121
    *               shift and go to state 122

    termx                          shift and go to state 171

state 149

    (9) vars -> VAR datatype varids store_type ; . vars
    (9) vars -> . VAR datatype varids store_type ; vars
    (10) vars -> .
    VAR             shift and go to state 47
    WHILE           reduce using rule 10 (vars -> .)
    INPUT           reduce using rule 10 (vars -> .)
    OUTPUT          reduce using rule 10 (vars -> .)
    IF              reduce using rule 10 (vars -> .)
    RETURN          reduce using rule 10 (vars -> .)
    ID              reduce using rule 10 (vars -> .)
    (               reduce using rule 10 (vars -> .)
    STRING          reduce using rule 10 (vars -> .)
    FLOAT           reduce using rule 10 (vars -> .)
    INT             reduce using rule 10 (vars -> .)
    FALSE           reduce using rule 10 (vars -> .)
    TRUE            reduce using rule 10 (vars -> .)
    }               reduce using rule 10 (vars -> .)

    vars                           shift and go to state 172

state 150

    (12) varids -> ID darray , . varids
    (11) varids -> . ID darray
    (12) varids -> . ID darray , varids
    (13) varids -> .
    ID              shift and go to state 83
    ;               reduce using rule 13 (varids -> .)

    varids                         shift and go to state 173

state 151

    (16) darray -> [ INT . ] twodarray
    ]               shift and go to state 174


state 152

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } . close_func functions
    (111) close_func -> .
    VOID            reduce using rule 111 (close_func -> .)
    D_BOOL          reduce using rule 111 (close_func -> .)
    D_STRING        reduce using rule 111 (close_func -> .)
    D_FLOAT         reduce using rule 111 (close_func -> .)
    D_INT           reduce using rule 111 (close_func -> .)
    VAR             reduce using rule 111 (close_func -> .)
    FUNC            reduce using rule 111 (close_func -> .)

    close_func                     shift and go to state 175

state 153

    (37) statement -> statement statement .
    (22) funcontent -> statement . funcontent
    (37) statement -> statement . statement
    (21) funcontent -> .
    (22) funcontent -> . statement funcontent
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 21 (funcontent -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for INPUT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for IF resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for ID resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for ( resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for STRING resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for } resolved using rule 21 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 21 (funcontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    statement                      shift and go to state 153
    funcontent                     shift and go to state 154
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 154

    (22) funcontent -> statement funcontent .
    }               reduce using rule 22 (funcontent -> statement funcontent .)


state 155

    (73) factor -> ( store_op expr ) . store_op
    (104) store_op -> .
    /               reduce using rule 104 (store_op -> .)
    *               reduce using rule 104 (store_op -> .)
    -               reduce using rule 104 (store_op -> .)
    +               reduce using rule 104 (store_op -> .)
    OR              reduce using rule 104 (store_op -> .)
    EQEQ            reduce using rule 104 (store_op -> .)
    DIFF            reduce using rule 104 (store_op -> .)
    AND             reduce using rule 104 (store_op -> .)
    <               reduce using rule 104 (store_op -> .)
    LOETHAN         reduce using rule 104 (store_op -> .)
    >               reduce using rule 104 (store_op -> .)
    GOETHAN         reduce using rule 104 (store_op -> .)
    ;               reduce using rule 104 (store_op -> .)
    )               reduce using rule 104 (store_op -> .)
    ,               reduce using rule 104 (store_op -> .)
    ]               reduce using rule 104 (store_op -> .)

    store_op                       shift and go to state 176

state 156

    (50) loop -> WHILE store_jump ( expr . ) store_gotof { statement } end_loop
    )               shift and go to state 177


state 157

    (49) input -> INPUT ( ID store_oper . ) ;
    )               shift and go to state 178


state 158

    (40) var_assign -> ID store_oper = idarray . ;
    (74) element -> idarray . store_oper
    (105) store_oper -> .
  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 179
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 141

state 159

    (42) var_assign -> ID store_oper = expr . ;
    ;               shift and go to state 180


state 160

    (90) idarray -> ID [ add_fstack expr . end_fstack ]
    (117) end_fstack -> .
    ]               reduce using rule 117 (end_fstack -> .)

    end_fstack                     shift and go to state 181

state 161

    (85) callfunc -> ID verify_func add_fstack ( . callfuncpar ver_params ) end_fstack store_gosub
    (86) callfuncpar -> .
    (87) callfuncpar -> . expr store_pquad callfuncparx
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    )               reduce using rule 86 (callfuncpar -> .)
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    callfuncpar                    shift and go to state 182
    expr                           shift and go to state 183
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 162

    (46) output -> OUTPUT ( expr outex . ) ;
    )               shift and go to state 184


state 163

    (48) outex -> , . expr outex
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 185
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 164

    (44) ifelse -> IF ( expr ) . store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> IF ( expr ) . store_gotof { statement } store_endif
    (119) store_gotof -> .
    {               reduce using rule 119 (store_gotof -> .)

    store_gotof                    shift and go to state 186

state 165

    (41) var_assign -> idarray store_oper = idarray . store_oper ;
    (74) element -> idarray . store_oper
    (105) store_oper -> .
    ;               reduce using rule 105 (store_oper -> .)
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)

    store_oper                     shift and go to state 187

state 166

    (38) var_assign -> idarray store_oper = expr . ;
    ;               shift and go to state 188


state 167

    (39) var_assign -> idarray store_oper = ID . store_oper ;
    (90) idarray -> ID . [ add_fstack expr end_fstack ]
    (85) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (79) compoundx -> ID . store_oper
    (105) store_oper -> .
    (115) verify_func -> .
    [               shift and go to state 99
    ;               reduce using rule 105 (store_oper -> .)
    /               reduce using rule 105 (store_oper -> .)
    *               reduce using rule 105 (store_oper -> .)
    -               reduce using rule 105 (store_oper -> .)
    +               reduce using rule 105 (store_oper -> .)
    OR              reduce using rule 105 (store_oper -> .)
    EQEQ            reduce using rule 105 (store_oper -> .)
    DIFF            reduce using rule 105 (store_oper -> .)
    AND             reduce using rule 105 (store_oper -> .)
    <               reduce using rule 105 (store_oper -> .)
    LOETHAN         reduce using rule 105 (store_oper -> .)
    >               reduce using rule 105 (store_oper -> .)
    GOETHAN         reduce using rule 105 (store_oper -> .)
    (               reduce using rule 115 (verify_func -> .)

    store_oper                     shift and go to state 189
    verify_func                    shift and go to state 100

state 168

    (65) arexpextra -> - term arexpextra .
    OR              reduce using rule 65 (arexpextra -> - term arexpextra .)
    EQEQ            reduce using rule 65 (arexpextra -> - term arexpextra .)
    DIFF            reduce using rule 65 (arexpextra -> - term arexpextra .)
    AND             reduce using rule 65 (arexpextra -> - term arexpextra .)
    <               reduce using rule 65 (arexpextra -> - term arexpextra .)
    LOETHAN         reduce using rule 65 (arexpextra -> - term arexpextra .)
    >               reduce using rule 65 (arexpextra -> - term arexpextra .)
    GOETHAN         reduce using rule 65 (arexpextra -> - term arexpextra .)
    ;               reduce using rule 65 (arexpextra -> - term arexpextra .)
    )               reduce using rule 65 (arexpextra -> - term arexpextra .)
    ,               reduce using rule 65 (arexpextra -> - term arexpextra .)
    ]               reduce using rule 65 (arexpextra -> - term arexpextra .)


state 169

    (66) arexpextra -> + term arexpextra .
    OR              reduce using rule 66 (arexpextra -> + term arexpextra .)
    EQEQ            reduce using rule 66 (arexpextra -> + term arexpextra .)
    DIFF            reduce using rule 66 (arexpextra -> + term arexpextra .)
    AND             reduce using rule 66 (arexpextra -> + term arexpextra .)
    <               reduce using rule 66 (arexpextra -> + term arexpextra .)
    LOETHAN         reduce using rule 66 (arexpextra -> + term arexpextra .)
    >               reduce using rule 66 (arexpextra -> + term arexpextra .)
    GOETHAN         reduce using rule 66 (arexpextra -> + term arexpextra .)
    ;               reduce using rule 66 (arexpextra -> + term arexpextra .)
    )               reduce using rule 66 (arexpextra -> + term arexpextra .)
    ,               reduce using rule 66 (arexpextra -> + term arexpextra .)
    ]               reduce using rule 66 (arexpextra -> + term arexpextra .)


state 170

    (70) termx -> / factor termx .
    -               reduce using rule 70 (termx -> / factor termx .)
    +               reduce using rule 70 (termx -> / factor termx .)
    OR              reduce using rule 70 (termx -> / factor termx .)
    EQEQ            reduce using rule 70 (termx -> / factor termx .)
    DIFF            reduce using rule 70 (termx -> / factor termx .)
    AND             reduce using rule 70 (termx -> / factor termx .)
    <               reduce using rule 70 (termx -> / factor termx .)
    LOETHAN         reduce using rule 70 (termx -> / factor termx .)
    >               reduce using rule 70 (termx -> / factor termx .)
    GOETHAN         reduce using rule 70 (termx -> / factor termx .)
    ;               reduce using rule 70 (termx -> / factor termx .)
    )               reduce using rule 70 (termx -> / factor termx .)
    ,               reduce using rule 70 (termx -> / factor termx .)
    ]               reduce using rule 70 (termx -> / factor termx .)


state 171

    (71) termx -> * factor termx .
    -               reduce using rule 71 (termx -> * factor termx .)
    +               reduce using rule 71 (termx -> * factor termx .)
    OR              reduce using rule 71 (termx -> * factor termx .)
    EQEQ            reduce using rule 71 (termx -> * factor termx .)
    DIFF            reduce using rule 71 (termx -> * factor termx .)
    AND             reduce using rule 71 (termx -> * factor termx .)
    <               reduce using rule 71 (termx -> * factor termx .)
    LOETHAN         reduce using rule 71 (termx -> * factor termx .)
    >               reduce using rule 71 (termx -> * factor termx .)
    GOETHAN         reduce using rule 71 (termx -> * factor termx .)
    ;               reduce using rule 71 (termx -> * factor termx .)
    )               reduce using rule 71 (termx -> * factor termx .)
    ,               reduce using rule 71 (termx -> * factor termx .)
    ]               reduce using rule 71 (termx -> * factor termx .)


state 172

    (9) vars -> VAR datatype varids store_type ; vars .
    WHILE           reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    INPUT           reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    OUTPUT          reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    IF              reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    RETURN          reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    ID              reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    (               reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    STRING          reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    FLOAT           reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    INT             reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    FALSE           reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    TRUE            reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)
    }               reduce using rule 9 (vars -> VAR datatype varids store_type ; vars .)


state 173

    (12) varids -> ID darray , varids .
    ;               reduce using rule 12 (varids -> ID darray , varids .)


state 174

    (16) darray -> [ INT ] . twodarray
    (17) twodarray -> .
    (18) twodarray -> . [ INT ]
    ,               reduce using rule 17 (twodarray -> .)
    ;               reduce using rule 17 (twodarray -> .)
    [               shift and go to state 190

    twodarray                      shift and go to state 191

state 175

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func . functions
    (19) functions -> . datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (20) functions -> .
    (92) datatype -> . VOID
    (93) datatype -> . D_BOOL
    (94) datatype -> . D_STRING
    (95) datatype -> . D_FLOAT
    (96) datatype -> . D_INT
    VAR             reduce using rule 20 (functions -> .)
    FUNC            reduce using rule 20 (functions -> .)
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 16
    functions                      shift and go to state 192

state 176

    (73) factor -> ( store_op expr ) store_op .
    /               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    *               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    -               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    +               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    OR              reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    EQEQ            reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    DIFF            reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    AND             reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    <               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    LOETHAN         reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    >               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    GOETHAN         reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    ;               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    )               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    ,               reduce using rule 73 (factor -> ( store_op expr ) store_op .)
    ]               reduce using rule 73 (factor -> ( store_op expr ) store_op .)


state 177

    (50) loop -> WHILE store_jump ( expr ) . store_gotof { statement } end_loop
    (119) store_gotof -> .
    {               reduce using rule 119 (store_gotof -> .)

    store_gotof                    shift and go to state 193

state 178

    (49) input -> INPUT ( ID store_oper ) . ;
    ;               shift and go to state 194


state 179

    (40) var_assign -> ID store_oper = idarray ; .
    WHILE           reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    INPUT           reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    OUTPUT          reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    IF              reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    RETURN          reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    ID              reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    (               reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    STRING          reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    FLOAT           reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    INT             reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    FALSE           reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    TRUE            reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)
    }               reduce using rule 40 (var_assign -> ID store_oper = idarray ; .)


state 180

    (42) var_assign -> ID store_oper = expr ; .
    WHILE           reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    INPUT           reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    OUTPUT          reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    IF              reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    RETURN          reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    ID              reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    (               reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    STRING          reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    FLOAT           reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    INT             reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    FALSE           reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    TRUE            reduce using rule 42 (var_assign -> ID store_oper = expr ; .)
    }               reduce using rule 42 (var_assign -> ID store_oper = expr ; .)


state 181

    (90) idarray -> ID [ add_fstack expr end_fstack . ]
    ]               shift and go to state 195


state 182

    (85) callfunc -> ID verify_func add_fstack ( callfuncpar . ver_params ) end_fstack store_gosub
    (114) ver_params -> .
    )               reduce using rule 114 (ver_params -> .)

    ver_params                     shift and go to state 196

state 183

    (87) callfuncpar -> expr . store_pquad callfuncparx
    (113) store_pquad -> .
    ,               reduce using rule 113 (store_pquad -> .)
    )               reduce using rule 113 (store_pquad -> .)

    store_pquad                    shift and go to state 197

state 184

    (46) output -> OUTPUT ( expr outex ) . ;
    ;               shift and go to state 198


state 185

    (48) outex -> , expr . outex
    (47) outex -> .
    (48) outex -> . , expr outex
    )               reduce using rule 47 (outex -> .)
    ,               shift and go to state 163

    outex                          shift and go to state 199

state 186

    (44) ifelse -> IF ( expr ) store_gotof . { statement } ELSE store_endif { statement }
    (45) ifelse -> IF ( expr ) store_gotof . { statement } store_endif
    {               shift and go to state 200


state 187

    (41) var_assign -> idarray store_oper = idarray store_oper . ;
    (74) element -> idarray store_oper .
  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 201
    /               reduce using rule 74 (element -> idarray store_oper .)
    *               reduce using rule 74 (element -> idarray store_oper .)
    -               reduce using rule 74 (element -> idarray store_oper .)
    +               reduce using rule 74 (element -> idarray store_oper .)
    OR              reduce using rule 74 (element -> idarray store_oper .)
    EQEQ            reduce using rule 74 (element -> idarray store_oper .)
    DIFF            reduce using rule 74 (element -> idarray store_oper .)
    AND             reduce using rule 74 (element -> idarray store_oper .)
    <               reduce using rule 74 (element -> idarray store_oper .)
    LOETHAN         reduce using rule 74 (element -> idarray store_oper .)
    >               reduce using rule 74 (element -> idarray store_oper .)
    GOETHAN         reduce using rule 74 (element -> idarray store_oper .)


state 188

    (38) var_assign -> idarray store_oper = expr ; .
    WHILE           reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    INPUT           reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    OUTPUT          reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    IF              reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    RETURN          reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    ID              reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    (               reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    STRING          reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    FLOAT           reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    INT             reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    FALSE           reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    TRUE            reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)
    }               reduce using rule 38 (var_assign -> idarray store_oper = expr ; .)


state 189

    (39) var_assign -> idarray store_oper = ID store_oper . ;
    (79) compoundx -> ID store_oper .
  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 202
    /               reduce using rule 79 (compoundx -> ID store_oper .)
    *               reduce using rule 79 (compoundx -> ID store_oper .)
    -               reduce using rule 79 (compoundx -> ID store_oper .)
    +               reduce using rule 79 (compoundx -> ID store_oper .)
    OR              reduce using rule 79 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 79 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 79 (compoundx -> ID store_oper .)
    AND             reduce using rule 79 (compoundx -> ID store_oper .)
    <               reduce using rule 79 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 79 (compoundx -> ID store_oper .)
    >               reduce using rule 79 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 79 (compoundx -> ID store_oper .)


state 190

    (18) twodarray -> [ . INT ]
    INT             shift and go to state 203


state 191

    (16) darray -> [ INT ] twodarray .
    ,               reduce using rule 16 (darray -> [ INT ] twodarray .)
    ;               reduce using rule 16 (darray -> [ INT ] twodarray .)


state 192

    (19) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .
    VAR             reduce using rule 19 (functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .)
    FUNC            reduce using rule 19 (functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .)


state 193

    (50) loop -> WHILE store_jump ( expr ) store_gotof . { statement } end_loop
    {               shift and go to state 204


state 194

    (49) input -> INPUT ( ID store_oper ) ; .
    WHILE           reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    INPUT           reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    OUTPUT          reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    IF              reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    RETURN          reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    ID              reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    (               reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    STRING          reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    FLOAT           reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    INT             reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    FALSE           reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    TRUE            reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)
    }               reduce using rule 49 (input -> INPUT ( ID store_oper ) ; .)


state 195

    (90) idarray -> ID [ add_fstack expr end_fstack ] .
    =               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    /               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    *               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    -               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    +               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    OR              reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    EQEQ            reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    DIFF            reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    AND             reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    <               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    LOETHAN         reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    >               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    GOETHAN         reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    ;               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    )               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    ,               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)
    ]               reduce using rule 90 (idarray -> ID [ add_fstack expr end_fstack ] .)


state 196

    (85) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params . ) end_fstack store_gosub
    )               shift and go to state 205


state 197

    (87) callfuncpar -> expr store_pquad . callfuncparx
    (88) callfuncparx -> .
    (89) callfuncparx -> . , callfuncpar
    )               reduce using rule 88 (callfuncparx -> .)
    ,               shift and go to state 207

    callfuncparx                   shift and go to state 206

state 198

    (46) output -> OUTPUT ( expr outex ) ; .
    WHILE           reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    INPUT           reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    OUTPUT          reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    IF              reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    RETURN          reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    ID              reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    (               reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    STRING          reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    FLOAT           reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    INT             reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    FALSE           reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    TRUE            reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)
    }               reduce using rule 46 (output -> OUTPUT ( expr outex ) ; .)


state 199

    (48) outex -> , expr outex .
    )               reduce using rule 48 (outex -> , expr outex .)


state 200

    (44) ifelse -> IF ( expr ) store_gotof { . statement } ELSE store_endif { statement }
    (45) ifelse -> IF ( expr ) store_gotof { . statement } store_endif
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 36 (statement -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 60
    statement                      shift and go to state 208
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 201

    (41) var_assign -> idarray store_oper = idarray store_oper ; .
    WHILE           reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    INPUT           reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    OUTPUT          reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    IF              reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    RETURN          reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    ID              reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    (               reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    STRING          reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    FLOAT           reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    INT             reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    FALSE           reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    TRUE            reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)
    }               reduce using rule 41 (var_assign -> idarray store_oper = idarray store_oper ; .)


state 202

    (39) var_assign -> idarray store_oper = ID store_oper ; .
    WHILE           reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    INPUT           reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    OUTPUT          reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    IF              reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    RETURN          reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    ID              reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    (               reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    STRING          reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    FLOAT           reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    INT             reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    FALSE           reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    TRUE            reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)
    }               reduce using rule 39 (var_assign -> idarray store_oper = ID store_oper ; .)


state 203

    (18) twodarray -> [ INT . ]
    ]               shift and go to state 209


state 204

    (50) loop -> WHILE store_jump ( expr ) store_gotof { . statement } end_loop
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 36 (statement -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 60
    statement                      shift and go to state 210
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 205

    (85) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) . end_fstack store_gosub
    (117) end_fstack -> .
    /               reduce using rule 117 (end_fstack -> .)
    *               reduce using rule 117 (end_fstack -> .)
    -               reduce using rule 117 (end_fstack -> .)
    +               reduce using rule 117 (end_fstack -> .)
    OR              reduce using rule 117 (end_fstack -> .)
    EQEQ            reduce using rule 117 (end_fstack -> .)
    DIFF            reduce using rule 117 (end_fstack -> .)
    AND             reduce using rule 117 (end_fstack -> .)
    <               reduce using rule 117 (end_fstack -> .)
    LOETHAN         reduce using rule 117 (end_fstack -> .)
    >               reduce using rule 117 (end_fstack -> .)
    GOETHAN         reduce using rule 117 (end_fstack -> .)
    ;               reduce using rule 117 (end_fstack -> .)
    )               reduce using rule 117 (end_fstack -> .)
    ,               reduce using rule 117 (end_fstack -> .)
    ]               reduce using rule 117 (end_fstack -> .)

    end_fstack                     shift and go to state 211

state 206

    (87) callfuncpar -> expr store_pquad callfuncparx .
    )               reduce using rule 87 (callfuncpar -> expr store_pquad callfuncparx .)


state 207

    (89) callfuncparx -> , . callfuncpar
    (86) callfuncpar -> .
    (87) callfuncpar -> . expr store_pquad callfuncparx
    (51) expr -> . arexp exprx
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
    )               reduce using rule 86 (callfuncpar -> .)
    (               shift and go to state 52
    ID              shift and go to state 105
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    callfuncpar                    shift and go to state 212
    expr                           shift and go to state 183
    arexp                          shift and go to state 68
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    idarray                        shift and go to state 104
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 208

    (44) ifelse -> IF ( expr ) store_gotof { statement . } ELSE store_endif { statement }
    (45) ifelse -> IF ( expr ) store_gotof { statement . } store_endif
    (37) statement -> statement . statement
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 214
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 60
    statement                      shift and go to state 213
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 209

    (18) twodarray -> [ INT ] .
    ,               reduce using rule 18 (twodarray -> [ INT ] .)
    ;               reduce using rule 18 (twodarray -> [ INT ] .)


state 210

    (50) loop -> WHILE store_jump ( expr ) store_gotof { statement . } end_loop
    (37) statement -> statement . statement
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 215
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 60
    statement                      shift and go to state 213
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 211

    (85) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack . store_gosub
    (118) store_gosub -> .
    /               reduce using rule 118 (store_gosub -> .)
    *               reduce using rule 118 (store_gosub -> .)
    -               reduce using rule 118 (store_gosub -> .)
    +               reduce using rule 118 (store_gosub -> .)
    OR              reduce using rule 118 (store_gosub -> .)
    EQEQ            reduce using rule 118 (store_gosub -> .)
    DIFF            reduce using rule 118 (store_gosub -> .)
    AND             reduce using rule 118 (store_gosub -> .)
    <               reduce using rule 118 (store_gosub -> .)
    LOETHAN         reduce using rule 118 (store_gosub -> .)
    >               reduce using rule 118 (store_gosub -> .)
    GOETHAN         reduce using rule 118 (store_gosub -> .)
    ;               reduce using rule 118 (store_gosub -> .)
    )               reduce using rule 118 (store_gosub -> .)
    ,               reduce using rule 118 (store_gosub -> .)
    ]               reduce using rule 118 (store_gosub -> .)

    store_gosub                    shift and go to state 216

state 212

    (89) callfuncparx -> , callfuncpar .
    )               reduce using rule 89 (callfuncparx -> , callfuncpar .)


state 213

    (37) statement -> statement statement .
    (37) statement -> statement . statement
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! reduce/reduce conflict for WHILE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for INPUT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for IF resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for ID resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for ( resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for STRING resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 37 (statement -> statement statement .)
  ! reduce/reduce conflict for } resolved using rule 37 (statement -> statement statement .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 37 (statement -> statement statement .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    statement                      shift and go to state 213
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 214

    (44) ifelse -> IF ( expr ) store_gotof { statement } . ELSE store_endif { statement }
    (45) ifelse -> IF ( expr ) store_gotof { statement } . store_endif
    (112) store_endif -> .
    ELSE            shift and go to state 217
    WHILE           reduce using rule 112 (store_endif -> .)
    INPUT           reduce using rule 112 (store_endif -> .)
    OUTPUT          reduce using rule 112 (store_endif -> .)
    IF              reduce using rule 112 (store_endif -> .)
    RETURN          reduce using rule 112 (store_endif -> .)
    ID              reduce using rule 112 (store_endif -> .)
    (               reduce using rule 112 (store_endif -> .)
    STRING          reduce using rule 112 (store_endif -> .)
    FLOAT           reduce using rule 112 (store_endif -> .)
    INT             reduce using rule 112 (store_endif -> .)
    FALSE           reduce using rule 112 (store_endif -> .)
    TRUE            reduce using rule 112 (store_endif -> .)
    }               reduce using rule 112 (store_endif -> .)

    store_endif                    shift and go to state 218

state 215

    (50) loop -> WHILE store_jump ( expr ) store_gotof { statement } . end_loop
    (121) end_loop -> .
    WHILE           reduce using rule 121 (end_loop -> .)
    INPUT           reduce using rule 121 (end_loop -> .)
    OUTPUT          reduce using rule 121 (end_loop -> .)
    IF              reduce using rule 121 (end_loop -> .)
    RETURN          reduce using rule 121 (end_loop -> .)
    ID              reduce using rule 121 (end_loop -> .)
    (               reduce using rule 121 (end_loop -> .)
    STRING          reduce using rule 121 (end_loop -> .)
    FLOAT           reduce using rule 121 (end_loop -> .)
    INT             reduce using rule 121 (end_loop -> .)
    FALSE           reduce using rule 121 (end_loop -> .)
    TRUE            reduce using rule 121 (end_loop -> .)
    }               reduce using rule 121 (end_loop -> .)

    end_loop                       shift and go to state 219

state 216

    (85) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .
    /               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    *               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    -               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    +               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    OR              reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    EQEQ            reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    DIFF            reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    AND             reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    <               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    LOETHAN         reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    >               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    GOETHAN         reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ;               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    )               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ,               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ]               reduce using rule 85 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)


state 217

    (44) ifelse -> IF ( expr ) store_gotof { statement } ELSE . store_endif { statement }
    (112) store_endif -> .
    {               reduce using rule 112 (store_endif -> .)

    store_endif                    shift and go to state 220

state 218

    (45) ifelse -> IF ( expr ) store_gotof { statement } store_endif .
    WHILE           reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    INPUT           reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    OUTPUT          reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    IF              reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    RETURN          reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    ID              reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    (               reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    STRING          reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    FLOAT           reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    INT             reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    FALSE           reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    TRUE            reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    }               reduce using rule 45 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)


state 219

    (50) loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .
    WHILE           reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    INPUT           reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    OUTPUT          reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    IF              reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    RETURN          reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    ID              reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    (               reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    STRING          reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    FLOAT           reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    INT             reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    FALSE           reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    TRUE            reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    }               reduce using rule 50 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)


state 220

    (44) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif . { statement }
    {               shift and go to state 221


state 221

    (44) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { . statement }
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 36 (statement -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 60
    statement                      shift and go to state 222
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 222

    (44) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement . }
    (37) statement -> statement . statement
    (29) statement -> . loop unload_pv
    (30) statement -> . input unload_pv
    (31) statement -> . output unload_pv
    (32) statement -> . ifelse unload_pv
    (33) statement -> . returns unload_pv ;
    (34) statement -> . expr ;
    (35) statement -> . var_assign unload_pv
    (36) statement -> .
    (37) statement -> . statement statement
    (50) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (49) input -> . INPUT ( ID store_oper ) ;
    (46) output -> . OUTPUT ( expr outex ) ;
    (44) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (45) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (43) returns -> . RETURN expr store_rquad
    (51) expr -> . arexp exprx
    (38) var_assign -> . idarray store_oper = expr ;
    (39) var_assign -> . idarray store_oper = ID store_oper ;
    (40) var_assign -> . ID store_oper = idarray ;
    (41) var_assign -> . idarray store_oper = idarray store_oper ;
    (42) var_assign -> . ID store_oper = expr ;
    (62) arexp -> . term arexpextra
    (63) arexp -> . term
    (90) idarray -> . ID [ add_fstack expr end_fstack ]
    (67) term -> . factor termx
    (68) term -> . factor
    (72) factor -> . element
    (73) factor -> . ( store_op expr ) store_op
    (74) element -> . idarray store_oper
    (75) element -> . callfunc store_oper
    (76) element -> . compound store_oper
    (77) element -> . const store_const
    (85) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (78) compound -> . compoundx
    (80) const -> . STRING
    (81) const -> . FLOAT
    (82) const -> . INT
    (83) const -> . FALSE
    (84) const -> . TRUE
    (79) compoundx -> . ID store_oper
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 223
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 77
    FLOAT           shift and go to state 78
    INT             shift and go to state 79
    FALSE           shift and go to state 80
    TRUE            shift and go to state 81

    expr                           shift and go to state 60
    statement                      shift and go to state 213
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    idarray                        shift and go to state 69
    term                           shift and go to state 70
    factor                         shift and go to state 71
    element                        shift and go to state 72
    callfunc                       shift and go to state 73
    compound                       shift and go to state 74
    const                          shift and go to state 75
    compoundx                      shift and go to state 76

state 223

    (44) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .
    WHILE           reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    INPUT           reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    OUTPUT          reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    IF              reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    RETURN          reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    ID              reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    (               reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    STRING          reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    FLOAT           reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    INT             reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    FALSE           reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    TRUE            reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    }               reduce using rule 44 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)


Conflicts:

shift/reduce conflict for VAR in state 5 resolved as shift
shift/reduce conflict for VAR in state 25 resolved as shift
shift/reduce conflict for WHILE in state 49 resolved as shift
shift/reduce conflict for INPUT in state 49 resolved as shift
shift/reduce conflict for OUTPUT in state 49 resolved as shift
shift/reduce conflict for IF in state 49 resolved as shift
shift/reduce conflict for RETURN in state 49 resolved as shift
shift/reduce conflict for ID in state 49 resolved as shift
shift/reduce conflict for ( in state 49 resolved as shift
shift/reduce conflict for STRING in state 49 resolved as shift
shift/reduce conflict for FLOAT in state 49 resolved as shift
shift/reduce conflict for INT in state 49 resolved as shift
shift/reduce conflict for FALSE in state 49 resolved as shift
shift/reduce conflict for TRUE in state 49 resolved as shift
shift/reduce conflict for WHILE in state 54 resolved as shift
shift/reduce conflict for INPUT in state 54 resolved as shift
shift/reduce conflict for OUTPUT in state 54 resolved as shift
shift/reduce conflict for IF in state 54 resolved as shift
shift/reduce conflict for RETURN in state 54 resolved as shift
shift/reduce conflict for ID in state 54 resolved as shift
shift/reduce conflict for ( in state 54 resolved as shift
shift/reduce conflict for STRING in state 54 resolved as shift
shift/reduce conflict for FLOAT in state 54 resolved as shift
shift/reduce conflict for INT in state 54 resolved as shift
shift/reduce conflict for FALSE in state 54 resolved as shift
shift/reduce conflict for TRUE in state 54 resolved as shift
shift/reduce conflict for WHILE in state 84 resolved as shift
shift/reduce conflict for INPUT in state 84 resolved as shift
shift/reduce conflict for OUTPUT in state 84 resolved as shift
shift/reduce conflict for IF in state 84 resolved as shift
shift/reduce conflict for RETURN in state 84 resolved as shift
shift/reduce conflict for ID in state 84 resolved as shift
shift/reduce conflict for ( in state 84 resolved as shift
shift/reduce conflict for STRING in state 84 resolved as shift
shift/reduce conflict for FLOAT in state 84 resolved as shift
shift/reduce conflict for INT in state 84 resolved as shift
shift/reduce conflict for FALSE in state 84 resolved as shift
shift/reduce conflict for TRUE in state 84 resolved as shift
shift/reduce conflict for WHILE in state 87 resolved as shift
shift/reduce conflict for INPUT in state 87 resolved as shift
shift/reduce conflict for OUTPUT in state 87 resolved as shift
shift/reduce conflict for IF in state 87 resolved as shift
shift/reduce conflict for RETURN in state 87 resolved as shift
shift/reduce conflict for ID in state 87 resolved as shift
shift/reduce conflict for ( in state 87 resolved as shift
shift/reduce conflict for STRING in state 87 resolved as shift
shift/reduce conflict for FLOAT in state 87 resolved as shift
shift/reduce conflict for INT in state 87 resolved as shift
shift/reduce conflict for FALSE in state 87 resolved as shift
shift/reduce conflict for TRUE in state 87 resolved as shift
shift/reduce conflict for WHILE in state 130 resolved as shift
shift/reduce conflict for INPUT in state 130 resolved as shift
shift/reduce conflict for OUTPUT in state 130 resolved as shift
shift/reduce conflict for IF in state 130 resolved as shift
shift/reduce conflict for RETURN in state 130 resolved as shift
shift/reduce conflict for ID in state 130 resolved as shift
shift/reduce conflict for ( in state 130 resolved as shift
shift/reduce conflict for STRING in state 130 resolved as shift
shift/reduce conflict for FLOAT in state 130 resolved as shift
shift/reduce conflict for INT in state 130 resolved as shift
shift/reduce conflict for FALSE in state 130 resolved as shift
shift/reduce conflict for TRUE in state 130 resolved as shift
shift/reduce conflict for WHILE in state 153 resolved as shift
shift/reduce conflict for INPUT in state 153 resolved as shift
shift/reduce conflict for OUTPUT in state 153 resolved as shift
shift/reduce conflict for IF in state 153 resolved as shift
shift/reduce conflict for RETURN in state 153 resolved as shift
shift/reduce conflict for ID in state 153 resolved as shift
shift/reduce conflict for ( in state 153 resolved as shift
shift/reduce conflict for STRING in state 153 resolved as shift
shift/reduce conflict for FLOAT in state 153 resolved as shift
shift/reduce conflict for INT in state 153 resolved as shift
shift/reduce conflict for FALSE in state 153 resolved as shift
shift/reduce conflict for TRUE in state 153 resolved as shift
shift/reduce conflict for ; in state 158 resolved as shift
shift/reduce conflict for ; in state 187 resolved as shift
shift/reduce conflict for ; in state 189 resolved as shift
shift/reduce conflict for WHILE in state 200 resolved as shift
shift/reduce conflict for INPUT in state 200 resolved as shift
shift/reduce conflict for OUTPUT in state 200 resolved as shift
shift/reduce conflict for IF in state 200 resolved as shift
shift/reduce conflict for RETURN in state 200 resolved as shift
shift/reduce conflict for ID in state 200 resolved as shift
shift/reduce conflict for ( in state 200 resolved as shift
shift/reduce conflict for STRING in state 200 resolved as shift
shift/reduce conflict for FLOAT in state 200 resolved as shift
shift/reduce conflict for INT in state 200 resolved as shift
shift/reduce conflict for FALSE in state 200 resolved as shift
shift/reduce conflict for TRUE in state 200 resolved as shift
shift/reduce conflict for WHILE in state 204 resolved as shift
shift/reduce conflict for INPUT in state 204 resolved as shift
shift/reduce conflict for OUTPUT in state 204 resolved as shift
shift/reduce conflict for IF in state 204 resolved as shift
shift/reduce conflict for RETURN in state 204 resolved as shift
shift/reduce conflict for ID in state 204 resolved as shift
shift/reduce conflict for ( in state 204 resolved as shift
shift/reduce conflict for STRING in state 204 resolved as shift
shift/reduce conflict for FLOAT in state 204 resolved as shift
shift/reduce conflict for INT in state 204 resolved as shift
shift/reduce conflict for FALSE in state 204 resolved as shift
shift/reduce conflict for TRUE in state 204 resolved as shift
shift/reduce conflict for } in state 208 resolved as shift
shift/reduce conflict for WHILE in state 208 resolved as shift
shift/reduce conflict for INPUT in state 208 resolved as shift
shift/reduce conflict for OUTPUT in state 208 resolved as shift
shift/reduce conflict for IF in state 208 resolved as shift
shift/reduce conflict for RETURN in state 208 resolved as shift
shift/reduce conflict for ID in state 208 resolved as shift
shift/reduce conflict for ( in state 208 resolved as shift
shift/reduce conflict for STRING in state 208 resolved as shift
shift/reduce conflict for FLOAT in state 208 resolved as shift
shift/reduce conflict for INT in state 208 resolved as shift
shift/reduce conflict for FALSE in state 208 resolved as shift
shift/reduce conflict for TRUE in state 208 resolved as shift
shift/reduce conflict for } in state 210 resolved as shift
shift/reduce conflict for WHILE in state 210 resolved as shift
shift/reduce conflict for INPUT in state 210 resolved as shift
shift/reduce conflict for OUTPUT in state 210 resolved as shift
shift/reduce conflict for IF in state 210 resolved as shift
shift/reduce conflict for RETURN in state 210 resolved as shift
shift/reduce conflict for ID in state 210 resolved as shift
shift/reduce conflict for ( in state 210 resolved as shift
shift/reduce conflict for STRING in state 210 resolved as shift
shift/reduce conflict for FLOAT in state 210 resolved as shift
shift/reduce conflict for INT in state 210 resolved as shift
shift/reduce conflict for FALSE in state 210 resolved as shift
shift/reduce conflict for TRUE in state 210 resolved as shift
shift/reduce conflict for WHILE in state 213 resolved as shift
shift/reduce conflict for INPUT in state 213 resolved as shift
shift/reduce conflict for OUTPUT in state 213 resolved as shift
shift/reduce conflict for IF in state 213 resolved as shift
shift/reduce conflict for RETURN in state 213 resolved as shift
shift/reduce conflict for ID in state 213 resolved as shift
shift/reduce conflict for ( in state 213 resolved as shift
shift/reduce conflict for STRING in state 213 resolved as shift
shift/reduce conflict for FLOAT in state 213 resolved as shift
shift/reduce conflict for INT in state 213 resolved as shift
shift/reduce conflict for FALSE in state 213 resolved as shift
shift/reduce conflict for TRUE in state 213 resolved as shift
shift/reduce conflict for WHILE in state 221 resolved as shift
shift/reduce conflict for INPUT in state 221 resolved as shift
shift/reduce conflict for OUTPUT in state 221 resolved as shift
shift/reduce conflict for IF in state 221 resolved as shift
shift/reduce conflict for RETURN in state 221 resolved as shift
shift/reduce conflict for ID in state 221 resolved as shift
shift/reduce conflict for ( in state 221 resolved as shift
shift/reduce conflict for STRING in state 221 resolved as shift
shift/reduce conflict for FLOAT in state 221 resolved as shift
shift/reduce conflict for INT in state 221 resolved as shift
shift/reduce conflict for FALSE in state 221 resolved as shift
shift/reduce conflict for TRUE in state 221 resolved as shift
shift/reduce conflict for } in state 222 resolved as shift
shift/reduce conflict for WHILE in state 222 resolved as shift
shift/reduce conflict for INPUT in state 222 resolved as shift
shift/reduce conflict for OUTPUT in state 222 resolved as shift
shift/reduce conflict for IF in state 222 resolved as shift
shift/reduce conflict for RETURN in state 222 resolved as shift
shift/reduce conflict for ID in state 222 resolved as shift
shift/reduce conflict for ( in state 222 resolved as shift
shift/reduce conflict for STRING in state 222 resolved as shift
shift/reduce conflict for FLOAT in state 222 resolved as shift
shift/reduce conflict for INT in state 222 resolved as shift
shift/reduce conflict for FALSE in state 222 resolved as shift
shift/reduce conflict for TRUE in state 222 resolved as shift
reduce/reduce conflict in state 49 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 49
reduce/reduce conflict in state 54 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 54
reduce/reduce conflict in state 70 resolved using rule arexp -> term
rejected rule (arexpextra -> <empty>) in state 70
reduce/reduce conflict in state 71 resolved using rule term -> factor
rejected rule (termx -> <empty>) in state 71
reduce/reduce conflict in state 84 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 84
reduce/reduce conflict in state 87 resolved using rule maincontent -> <empty>
rejected rule (statement -> statement statement) in state 87
reduce/reduce conflict in state 87 resolved using rule statement -> statement statement
rejected rule (statement -> <empty>) in state 87
reduce/reduce conflict in state 87 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 87
reduce/reduce conflict in state 130 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 130
reduce/reduce conflict in state 153 resolved using rule funcontent -> <empty>
rejected rule (statement -> statement statement) in state 153
reduce/reduce conflict in state 153 resolved using rule statement -> statement statement
rejected rule (statement -> <empty>) in state 153
reduce/reduce conflict in state 153 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 153
reduce/reduce conflict in state 213 resolved using rule statement -> statement statement
rejected rule (statement -> <empty>) in state 213